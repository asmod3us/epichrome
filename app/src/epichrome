#!/bin/sh
#
#  Epichrome: Run an Epichrome app
#
#  Copyright (C) 2020  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  Full license at: http://www.gnu.org/licenses/ (V3,6/29/2007)
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


# BUILD FLAGS (CAN BE OVERRIDDEN BY RUNTIME.SH)

debug=
logPreserve=


# FUNCTION DEFINITIONS

# ABORT -- display an error alert and abort
function abort { # [myErrMsg code]

    # arguments
    local myErrMsg="$1" ; shift ; [[ "$myErrMsg" ]] || myErrMsg="$errmsg"
    local myCode="$1"   ; shift ; [[ "$myCode"   ]] || myCode=1
    
    # log error message
    local myAbortLog="Aborting: $myErrMsg"
    if [[ "$( type -t errlog )" = function ]] ; then
	errlog "$myAbortLog"
    else
	echo "$myAbortLog" 1>&2
	[[ -w "$logPath" ]] && echo "$myAbortLog" >> "$logPath"
    fi
    
    # show dialog & offer to open log
    local choice=
    if [[ "$( type -t dialog )" = function ]] ; then
	dialog choice "$myErrMsg" "Unable to Run" '|stop' '+Quit' '-View Log'
	if [[ "$choice" = 'View Log' ]] ; then
	    
	    # clear OK state so try works & ignore result
	    ok=1 ; errmsg=
	    try /usr/bin/osascript -e '
tell application "Finder" to reveal ((POSIX file "'"$logPath"'") as alias)
tell application "Finder" to activate' 'Error attempting to view log file.'
	fi
    else

	# dialog function not defined (we could be pre-runtime load)
	/usr/bin/osascript -e 'display dialog "'"$myErrMsg"'" with title "Unable to Run" with icon stop buttons {"Quit"} default button "Quit"'
    fi
    
    # quit with error code
    exit "$myCode"
}


# UNSUDO -- run a command as the original user
function unsudo {
    if [[ "$isAdmin" ]] ; then
        sudo -u $USER "$@"
        local result="$?"
    else
        "$@"
        local result="$?"
    fi

    return "$result"
}


# RELAUNCH -- relaunch this app after a delay
function relaunch { # APP-PATH DELAY-SECONDS
    [[ "$2" ]] && sleep "$2"
    open "$1"
}


# AUTHENTICATE -- relaunch authenticated if necessary
isAuthenticated=
function authenticate {  # ID PREAMBLE MESSAGE NONFATAL (If NONFATAL exists, return 1 on auth fail)

    # only run if no error
    if [[ "$ok" ]]; then

	# get ID of this authentication to pass to self
	local id="$1"
	shift
	[[ "$id" ]] || id="admin"

	# build preamble
	local preamble="$1"
	shift
	[[ "$preamble" ]] && preamble="$preamble "

	# build alert message
	local msg="$1"
	shift
	[[ ! "$msg" ]] && msg="update"

	# get nonfatal argument
	local nonfatal="$1"

	# only check if we're not already authenticated
	if [[ ! "$isAuthenticated" ]] ; then

	    # try to touch the app bundle--if we can, we have the privileges we need
	    cmdtext=$(/usr/bin/touch "$myPath" 2>&1)

	    if [[ "$?" != 0 ]] ; then

		local doAuth=
		errre='Permission denied$'
		if [[ ! "$cmdtext" =~ $errre ]] ; then

		    # some other error (not permission denied)
		    msg="Error attempting to determine if authentication is required."

		    if [[ "$nonfatal" ]] ; then
			alert "$msg" 'Warning' '|caution'
		    else
			abort "$msg" 1
		    fi
		else

		    # permission denied to touch this file--ask to authenticate
		    dialog doAuth "${preamble}In order to $msg, the app must run with administrator privileges." "Authentication Required" "|caution" "Authenticate" "+Cancel"

		    # user wants to authenticate
		    if [[ "$doAuth" = "Authenticate" ]] ; then

			# replace ourself with an authenticated version
			#of the same script running with admin privileges
			#exec osascript -e 'do shell script "su -m '"$USER"' -c \"" & (quoted form of "'"${0//\"/\\\\\\\"}"'") & "\"" with administrator privileges'

			# add debug flag if it was set for us
			local debugOpt='""'
			[[ "$debug" ]] && debugOpt='" --debug "'

			exec osascript -e 'do shell script (quoted form of "'"$0"'") & " --epichrome-admin " & $debugOpt & (quoted form of "'"$id"'") with administrator privileges'

		    elif [[ "$nonfatal" ]] ; then
			return 1
		    else
			abort "Please relaunch with administrator privileges." 1
		    fi
		fi
	    else
		isAuthenticated=1
	    fi
	fi
    fi

    # all went well, we are authenticated!
    [[ "$ok" ]] && return 0
    return 1
}


# LINKTREE: hard link to a directory or file
function linktree { # $1 = sourcedir (absolute)
    #                 $2 = destdir (absolute)
    #                 $3 = try error identifier
    #                 $@ = <files>

    if [[ "$ok" ]]; then

	# read arguments
	local sourcedir="$1"  # could absolutize: echo "$(cd "$foo" 2> /dev/null && pwd)"
	local destdir="$2"
	local tryid="$3"
	shift 3

	# make sure both directories are on the same filesystem
	local sourceDevice=
	try 'sourceDevice=' /usr/bin/stat -f '%d' "$sourcedir" \
	    "Unable to get info on $sourcedir."
	local destDevice=
	try 'destDevice=' /usr/bin/stat -f '%d' "$destdir" \
	    "Unable to get info on $destdir."

	if [[ "$ok" ]] ; then
	    if [[ "$sourceDevice" != "$destDevice" ]]; then
		ok=
		errmsg="$entry must be on the same drive as this app."
	    fi
	fi

	if [[ "$ok" ]] ; then
	    # pushd to source directory
	    try '/dev/null&<' pushd "$sourcedir" \
		"$tryid link error: Unable to move to $sourcedir"

	    local files=
	    if [[ "$@" ]] ; then
		files=( "$@" )
	    else
		# no items specified, so link all non-dot items
		files=( * )
	    fi

	    # loop through entries creating hard links
	    for entry in "${files[@]}" ; do
		# hard link
		try /bin/pax -rwlpp "$entry" "$destdir" \
		    "$tryid link error: Unable to create link to $entry."
	    done

	    # popd back from source directory
	    try '/dev/null&<' popd \
		"$tryid link error: Unable to move back from $sourcedir."
	fi
    fi
}


# GETENGINEPID: get the PID of the running engine
enginePID=
function getenginepid { # ENGINE-BUNDLE-ID ENGINE-BUNDLE-PATH

    # assume no PID
    enginePID=

    # args
    local id="$1"
    local path="$2"

    # get all ASNs associated with the engine's bundle ID
    local asns=
    try 'asns=()' /usr/bin/lsappinfo find "bundleid=$id" \
	'Error while attempting to find running engine.'

    # no engine found, just don't return a PID
    if [[ "$ok" && ( "${#asns[@]}" = 0 ) ]] ; then
	return 0
    fi

    # search for PID
    if [[ "$ok" ]] ; then

	local info=

	local a=
	for a in "${asns[@]}" ; do

	    # get info on an ASN (we use try for the debugging output)
	    try 'info=' /usr/bin/lsappinfo info "$a" ''
	    ok=1 ; errmsg=

	    # if this ASN matches our bundle, grab the PID
	    re='bundle path *= *"([^'$'\n'']+)".*pid *= *([0-9]+)'
	    if [[ ( "$info" =~ $re ) && ( "${BASH_REMATCH[1]}" = "$path" ) ]] ; then
		enginePID="${BASH_REMATCH[2]}"
		break
	    fi

	    # not found, so reset info
	    info=
	done
    fi

    # return result
    if [[ "$enginePID" ]] ; then
	ok=1 ; errmsg=
	return 0
    elif [[ "$ok" ]] ; then
	return 0
    else
	# errors in this function are nonfatal; just return the error message
	ok=1
	return 1
    fi
}


# MAIN BODY


# PARSE COMMAND-LINE OPTIONS

isAdmin=
argsURIs=()
argsOptions=()
while [[ "$#" -gt 0 ]] ; do
    case "$1" in
        --epichrome-admin)
	    isAdmin="$1"
            ;;

        --epichrome-debug)
            debug=1
            ;;

	--epichrome-preserve-logs)
	    logPreserve=1
	    ;;

	[hH][tT][tT][pP]'://'*|[hH][tT][tT][pP][sS]'://'*|[fF][tT][pP]'://'*|[fF][iI][lL][eE]'://'*)
	    # this should be sent to the open command
	    argsURIs+=( "$1" )
	    ;;

	*)
	    # pass any other options along to the engine
	    argsOptions+=( "$1" )
    esac

    # get next arg
    shift
done


# BOOTSTRAP THIS APP'S RUNTIME SCRIPT

# temporary logApp until we read config
logApp="${0%.[aA][pP][pP]/*}"
logApp="${logApp##*/}"

source "${0%/*}/Scripts/runtime.sh"
[[ "$?" != 0 ]] && abort 'Unable to load runtime script.'
[[ "$ok" ]] || abort

# path to this app
myPath="${BASH_SOURCE[0]%/Contents/Resources/script}"

# set absolute paths from hardcoded relative ones
myContents="$myPath/Contents"
myCleanupPath="$myContents/$appCleanupPath"


# GET BASIC APP INFORMATION

# load config.sh file
readconfig "$myContents"

[[ "$ok" ]] || abort


# SET UP USER DATA PATHS

# get absolute data directory path
myDataPath="${HOME}/$SSBDataPath"

# get app engine user data path
myProfilePath="$myDataPath/$appDataProfileBase"
myProfilePathArg="--user-data-dir=$myProfilePath"

# set path to app engine (in profile folder)
myEnginePath="$myDataPath/$appDataEngineBase"
myPayloadPath="$myDataPath/$appDataPayloadBase"
myPayloadContents="$myPayloadPath/Contents"


# UPDATE ENGINE APP NAME & PATH

# regex for pulling out current app name
appNameRe='/([^/]+)\.[aA][pP][pP]$'

# try to use current name of this Epichrome app as engine name
if [[ "$myPath" =~ $appNameRe ]] ; then
    SSBEngineAppName="${BASH_REMATCH[1]}.app"
else
    # if app name is unparsable, just use Info.plist display name
    SSBEngineAppName="${CFBundleDisplayName}.app"
fi

# get path to engine app bundle
myEngineAppPath="$myEnginePath/$SSBEngineAppName"
myEngineAppContents="$myEngineAppPath/Contents"

# override runtime.sh debug log path & start fresh
logApp="$CFBundleName"
logPath="$myDataPath/epichrome_app_log.txt"
stderrTempFile="$myDataPath/stderr.txt"

# initialize the log
initlog

# by default, use existing profile
newprofile=

# log config.sh info
[[ "$debug" ]] && readconfig  # just log previously read config


# IF THE ENGINE IS ALREADY RUNNING, SEND ANY FILES TO RUNNING ENGINE & QUIT

# get the ID of the engine app
if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
    myEngineID="$googleChromeID"
else
    myEngineID="${appEngineIDBase}.${SSBIdentifier}"
fi

# determine if the engine is running
getenginepid "$myEngineID" "$myEngineAppPath"
if [[ "$?" != 0 ]] ; then
    debuglog "Unable to determine if app engine is running: $errmsg"
fi

if [[ "$enginePID" ]] ; then

    # engine is already running, so just send any files or URLs to it &
    # don't run the usual command-line
    
    try /usr/bin/open -a "$myEngineAppPath" "${argsURIs[@]}" \
	'Unable to connect to running app engine.'
    
    # we're done, so exit
    [[ "$ok" ]] && exit 0
    exit 1
fi


# ENGINE IS NOT RUNNING, SO GATHER MORE INFO

if [[ "$SSBEngineType" = "Google Chrome" ]] ; then

    # get info on the installed Google Chrome
    googlechromeinfo
fi

# abort on error
[[ "$ok" ]] || abort "$errmsg" 1


# CHECK FOR NEW VERSION OF EPICHROME AND UPDATE

# get info on latest Epichrome version
epichromeinfo
[[ "$ok" ]] || abort "$errmsg"
epiLatestVersion="${epiLatest[$e_version]}"

if vcmp "$SSBUpdateVersion" '<' "$epiLatestVersion" ; then

    # authenticate
    authenticate epichromeupdate "A new version of the Epichrome runtime was found ($epiLatestVersion)." \
		 'update' nonfatal
    if [[ "$?" = 0 ]] ; then

	# Ask about updating (unless we asked with the authentication dialog)
	if [[ "$isAdmin" != epichromeupdate ]] ; then
	    dialog doUpdate \
		   "A new version of the Epichrome runtime was found ($epiLatestVersion). Would you like to update now?" \
		   "Update" \
		   "|caution" \
		   "+Update" \
		   "-Later" \
		   "Don't Ask Again For This Version"
	    if [[ ! "$ok" ]] ; then
		alert "A new version of the Epichrome runtime was found ($epiLatestVersion) but the update dialog failed. Attempting to update now." 'Update' '|caution'
		doUpdate="Update"
		ok=1
		errmsg=
	    fi
	else
	    doUpdate="Update"
	fi

	if [[ "$ok" ]] ; then

	    # act based on dialog
	    case "$doUpdate" in
		Update)

		    # read in the new runtime
		    safesource "${epiLatest[$e_contents]}/Resources/Scripts/update.sh" "update script $epiLatestVersion"

		    # use new runtime to update the SSB (and relaunch)
		    updateapp "$myPath"
		    
		    if [[ "$ok" ]] ; then
			
			# SUCCESS -- relaunch after a delay
			relaunch "$myPath" 1 &
			disown -ar
			exit 0

		    else

			# UPDATE FAILED -- reload my runtime
			
			# temporarily turn OK back on & reload old runtime
			oldErrmsg="$errmsg" ; errmsg=
			oldOK="$ok" ; ok=1
			safesource "$myPath/Contents/Resources/Scripts/runtime.sh" "runtime script $SSBVersion"
			[[ "$ok" ]] && ok="$oldOK"
			
			# update error message
			if [[ "$oldErrmsg" && "$errmsg" ]] ; then
			    errmsg="$oldErrmsg $errmsg"
			elif [[ "$oldErrmsg" ]] ; then
			    errmsg="$oldErrmsg"
			fi
		    fi
		    ;;

		Later)
		    # don't update
		    doUpdate=
		    ;;

		*)
		    # pretend we're already at the new version
		    SSBUpdateVersion="$epiLatestVersion"
		    ;;
	    esac
	fi

	# alert the user to any error, but don't abort
	if [[ ! "$ok" ]] ; then
	    alert "$errmsg Please try update again later." 'Unable to Update' '|caution'
	    ok=1
	    errmsg=
	fi
    fi
fi


# CHECK FOR A NEW VERSION OF EPICHROME ON GITHUB

try 'curDate=' /bin/date '+%s' 'Unable to get date for Epichrome update check.'
if [[ "$ok" ]] ; then

    # check for updates if we've never run a check, or if the next check date is in the past
    if [[ ( ! "$SSBUpdateCheckDate" ) || ( "$SSBUpdateCheckDate" -lt "$curDate" ) ]] ; then

	# set next update for 7 days from now
	SSBUpdateCheckDate=$(($curDate + (7 * 24 * 60 * 60)))

	# if we haven't set a version to check against, use the latest version
	[[ "$SSBUpdateCheckVersion" ]] || SSBUpdateCheckVersion="$epiLatestVersion"

	# check if there's a new version on Github
	try 'updateResult=(n)' checkepichromeversion "$myContents" "$SSBUpdateCheckVersion" \
	    'Unable to check for a new version of Epichrome on Github.'
	if [[ ! "$ok" ]] ; then
	    alert "Warning: $errmsg" 'Checking For Update' '|caution'
	    ok=1
	else
	    
	    # if there's an update available, display a dialog
	    if [[ "${updateResult[*]}" ]] ; then
		
		# display dialog
		dialog doEpichromeUpdate \
		   "A new version of Epichrome (${updateResult[0]}) is available on GitHub." \
		   "Update Available" \
		   "|caution" \
		   "+Download" \
		   "-Later" \
		   "Ignore This Version"

		# act based on dialog
		if [[ "$ok" ]] ; then

		    case "$doEpichromeUpdate" in
			Download)
			    # open the update URL
			    open "${updateResult[1]}"
			    ;;

			Later)
			    # do nothing
			    doEpichromeUpdate=
			    ;;
			*)
			    # pretend we're already at the new version
			    SSBUpdateCheckVersion="${updateResult[0]}"
			    ;;
		    esac
		fi

		# alert the user to any error, but don't abort
		if [[ ! "$ok" ]] ; then
		    alert "Warning: $errmsg" 'Checking For Update' '|caution'
		    ok=1
		fi

		IFS="$oldifs"
	    fi
	fi
    fi
fi

[[ "$ok" ]] || abort "$errmsg" 1


# BUILD ENGINE ON THE FLY

# RECREATE PAYLOAD IF NECESSARY
# (due to new Google Chrome version, new Chromium engine version, or corrupt or missing payload)

# status variable to decide if we need to recreate the payload
newPayload=
payloadErrmsg=

# check for new engine versions

if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
    
    # new version of Google Chrome
    if [[ "$SSBEngineVersion" != "$configSSBEngineVersion" ]] ; then
	debuglog "Updating payload with new version of Google Chrome ($SSBEngineVersion)."
	newPayload=1
	payloadErrmsg="Unable to update app to new version of Google Chrome app engine."
    fi
else
    
    # new version of Epichrome with Chromium engine
    if [[ "$SSBEngineVersion" != "${epiCompatible[$e_version]}" ]] ; then
	debuglog "Updating payload with new version of Epichrome app engine."
	newPayload=1
	payloadErrmsg="Unable to update app to new version of app engine."
	
	SSBEngineVersion="${epiCompatible[$e_version]}"
    fi
fi

# check for missing or corrupt payload

if [[ ! "$newPayload" ]] ; then
    
    if [[ ( ! -d "$myPayloadPath" ) || ( ! -d "$myPayloadContents/Resources" ) ]] ; then
	debuglog "Replacing missing app engine payload"
	newPayload=1
	payloadErrmsg="Unable to replace missing app engine payload."
    else
	
	# check for corrupt Payload directory
	
	# get manifest of current Payload directory
	payloadManifest="$(cd "$myPayloadPath" && /usr/bin/find -L . -print | /usr/bin/sort)"
	if [[ "$?" != 0 ]] ; then
	    debuglog "Failed to get manifest of app engine payload."
	    newPayload=1
	else
	    if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
		# get Google Chrome payload manifest
		engineManifest="$(cd "$SSBGoogleChromePath" && /usr/bin/find -L . -path '.' -print -or -path './Contents' -print -or -path './Contents/Resources' -print -or -path './Contents/Resources*' -path '*.lproj*' -not -path './Contents/*/Contents/*' -print -or -path './Contents/Resources/*.icns' -print | /usr/bin/sort)"
		if [[ "$?" != 0 ]] ; then
		    debuglog "Failed to get manifest of Google Chrome app engine."
		    newPayload=1
		fi
	    else
		
		# get Epichrome Chromium payload manifest
		engineManifest="$(cd "${epiCompatible[$e_enginePayload]}" && (echo './Contents/Resources/app.icns' && echo './Contents/Resources/document.icns' && /usr/bin/find -L . -print) | /usr/bin/sed -E -e 's/InfoPlist\.strings.in/InfoPlist.strings/' -e 's/Info.plist.in/Info.plist.off/' | /usr/bin/sort)"
		if [[ "$?" != 0 ]] ; then
		    debuglog "Failed to get manifest of Epichrome app engine payload."
		    newPayload=1
		fi
	    fi
	    
	    if [[ "$payloadManifest" != "$engineManifest" ]] ; then
		debuglog "App payload doesn't match engine source payload."
		newPayload=1
	    fi
	fi
	
	[[ "$newPayload" ]] && payloadErrmsg="Unable to replace corrupt app engine Payload."
    fi
fi

# create a new engine payload if needed
if [[ "$newPayload" ]] ; then
    
    createenginepayload "$myContents" "$myDataPath" "${epiCompatible[$e_enginePayload]}"

    [[ "$ok" ]] || abort "$payloadErrmsg ($errmsg)"
fi


# BUILD ENGINE OUT OF PAYLOAD

# rename Payload to engine app name
try /bin/mv "$myPayloadPath" "$myEngineAppPath" 'Unable to create app engine from payload.'

[[ "$ok" ]] || abort "$errmsg" 1

if [[ "$SSBEngineType" != "Google Chrome" ]] ; then

    # EPICHROME CHROMIUM ENGINE
    
    if [[ ! "$epiCompatible" ]] ; then
	abort "Unable to find a version of Epichrome compatible with this app's engine."
    fi
    # link to everything except Resources directory
    dirlist "${epiCompatible[e_engineRuntime]}" curdir 'Epichrome app engine' '^Resources$'
    linktree "${epiCompatible[e_engineRuntime]}" "$myEngineAppContents" \
	     'Epichrome app engine' "${curdir[@]}"

    # link to everything in Resources
    linktree "${epiCompatible[e_engineRuntime]}/Resources" "$myEngineAppContents/Resources" \
	     'Epichrome app engine Resources'

    try /bin/mv -f "$myEngineAppContents/Info.plist.off" \
	"$myEngineAppContents/Info.plist" \
	'Unable to activate payload Info.plist.'
else
    # GOOGLE CHROME ENGINE

    # link to everything except Resources & MacOS directories
    dirlist "$googleChromeContents" curdir \
	    'Google Chrome app engine' '^((Resources)|(MacOS))$'
    linktree "$googleChromeContents" "$myEngineAppContents" \
	     'Google Chrome app engine' "${curdir[@]}"

    # link to everything in Resources except .lproj & .icns
    dirlist "$googleChromeContents/Resources" curdir \
	    'Google Chrome app engine Resources' '\.((icns)|(lproj))$'
    linktree "$googleChromeContents/Resources" "$myEngineAppContents/Resources" \
	     'Google Chrome app engine Resources' \
	     "${curdir[@]}"
fi

# abort on error
[[ "$ok" ]] || abort


# HANDLE FIRST-RUN SETUP


# CREATE PROFILE FOLDER IF IT DOESN'T ALREADY EXIST

# create profile folder   $$$ REMOVE UNSUDO ON DEAUTH PASS??
if [[ ! -d "$myProfilePath" ]]; then
    newprofile=1
    try unsudo /bin/mkdir -p "$myProfilePath" 'Unable to create app engine profile folder.'
    [[ "$ok" ]] || abort
fi

# $$$ GET RID OF THIS AND USE MASTER PREFS?? OR REMOVE UNSUDO
# set First Run file so Chrome/Chromium doesn't think it's new (fail silently)
firstrunfile="$myProfilePath/First Run"
[[ -e "$firstrunfile" ]] || unsudo touch "$firstrunfile" > /dev/null 2>&1


# MOVE EXTENSION-INSTALLATION SCRIPT INTO PLACE

extDoCopy=
if [[ "$SSBFirstRunSinceVersion" || "$newprofile" ]]; then

    # set up useful variables
    extDir="External Extensions"
    extSourcePath="$myContents/Resources/$extDir"
    extDestPath="$myProfilePath/$extDir"
    
    # make sure the extension install source folder exists
    if [[ ! -d "$extSourcePath" ]] ; then
	ok=
	errmsg='No source directory found.'
    fi

    # get a listing of the source directory
    dirlist "$extSourcePath" extSourceList 'source directory'

    # check if the source directory is empty
    if [[ "$ok" && ( ! "${extSourceList[*]}" ) ]]; then
	ok=
	errmsg='The source directory is empty.'
    fi

    # check if the destination directory exists
    if [[ "$ok" ]] ; then
	if [[ -e "$extDestPath" && ! -d "$extDestPath" ]]; then
	    # found something other than a directory, get rid of it
	    try rm -f "$extDestPath" 'Unable to clean up destination directory.'
	fi

	if [[ "$ok" && ! -d "$extDestPath" ]] ; then
	    # no destination directory
	    extDoCopy=1
	else
	    # get a listing of the destination directory
	    dirlist "$extDestPath" extDestList 'destination directory'

	    # compare source and destination directories
	    if [[ "$ok" && ( "${extSourceList[*]}" != "${extDestList[*]}" ) ]] ; then
		extDoCopy=1
	    fi
	fi
    fi

    # $$$$ REMOVE UNSUDO??
    # if for any reason we need to copy the install directory, do it now
    if [[ "$ok" && "$extDoCopy" ]] ; then
	unsudo safecopy "$extSourcePath" "$extDestPath" 'installation directory'
    fi

    # report error, but don't abort
    if [[ ! "$ok" ]] ; then
	# show warning alert
	alert "Can't install \"Epichrome Helper\" extension. ($errmsg) Your app will still work, but if you want to use the extension, you'll have to install it manually." 'Extension Install Error' '|caution'

	# clear extension copy state
	extDoCopy=

	# clear error state
	ok=1 ; errmsg=
    fi
fi


# MAKE SURE NATIVE HOST IS INSTALLED

if [[ ! "$SSBHostInstallError" ]]; then

    # set up host file paths
    hostManifest=( "org.epichrome.runtime.json" "org.epichrome.helper.json" )
    hostScript="epichromeruntimehost.py"
    hostDir="NativeMessagingHosts"
    hostInstallPath="$myProfilePath/$hostDir"
    hostScriptInstalled="$hostInstallPath/$hostScript"
    hostManifestInstalled=( "$hostInstallPath/${hostManifest[0]}" "$hostInstallPath/${hostManifest[1]}" )

    # check if we need to install native messaging host
    doHostInstall=

    # do it if we just updated, or the host script or manifest don't exist
    if [[ "$SSBFirstRunSinceVersion" || \
	      ( ! -x "$hostScriptInstalled" ) || \
	      ( ! -e "${hostManifestInstalled[0]}" ) || \
	      ( ! -e "${hostManifestInstalled[1]}" ) ]] ; then
	doHostInstall=1
    else
	# get installed host version if possible
	try 'hostVersion=' "$hostScriptInstalled" -v ''
	if [[ ! "$ok" ]] ; then
	    hostVersion=0.0.0
	    ok=1 ; errmsg=
	fi

	# if installed host is old, we'll update it
	vcmp "$hostVersion" '<' "$epiLatestVersion" && doHostInstall=1
    fi

    # make sure the manifest points to the current path of the script
    if [[ ! "$doHostInstall" ]] ; then

	for hmi in "${hostManifestInstalled[@]}" ; do

	    # get path to script in the manifest
	    try 'oldHostScriptInstalled=' sed -En \
		's/^.*"path": "(.*)",[ ]*(\/\/.*)?$/\1/p' "$hmi" \
		'Unable to get current host script path'

	    # on error, or if the paths don't match, reinstall
	    if [[ ! "$ok" || \
		      ("$oldHostScriptInstalled" != "$hostScriptInstalled") ]] ; then
		ok=1 ; errmsg=
		doHostInstall=1
	    fi

	done
    fi

    # do the installation if necessary
    if [[ "$doHostInstall" ]] ; then

	hostSourcePath="$myContents/Resources/$hostDir"

	# create the install directory
	try unsudo /bin/mkdir -p "$hostInstallPath" \
	    'Unable to create installation folder.'

	# stream-edit the host script  $$$ UNSUDO
	hostScriptTmp=$(tempname "$hostScriptInstalled")
	try unsudo /usr/bin/touch "${hostScriptTmp}" \
	    'Unable to create script.'
	try "${hostScriptTmp}<" sed \
	    "s/APPBUNDLEID/${appIDBase}.${SSBIdentifier}/; s/APPDISPLAYNAME/$CFBundleDisplayName/; s/APPBUNDLENAME/$CFBundleName/;" \
	    "$hostSourcePath/$hostScript" 'Unable to copy script.'

	# fix host script permissions
	try /bin/chmod 755 "$hostScriptTmp" 'Unable to make script executable.'

	# move script to permanent home
	permanent "$hostScriptTmp" "$hostScriptInstalled" 'script'

	# on error, remove temporary file
	if [[ ! "$ok" ]] ; then
	    [[ -e "$hostScriptTmp" ]] && rmtemp "$hostScriptTmp" 'script'
	fi

	index=0
	for hmi in "${hostManifestInstalled[@]}" ; do

	    # stream-edit the manifest file
	    hostManifestTmp=$(tempname "$hmi")
	    try unsudo /usr/bin/touch "${hostManifestTmp}" \
		'Unable to create manifest.'
	    try "${hostManifestTmp}<" sed \
		"s/APPHOSTPATH/${hostScriptInstalled//\//\\/}/" \
		"$hostSourcePath/${hostManifest[$index]}" \
		'Unable to copy manifest.'

	    # move manifest to permanent home
	    permanent "$hostManifestTmp" "$hmi" 'manifest'

	    # on error, remove temporary file
	    if [[ ! "$ok" ]] ; then
		[[ -e "$hostManifestTmp" ]] && \
		    rmtemp "$hostManifestTmp" 'manifest'
	    fi

	    index=$(($index + 1))
	done

	# report error, but don't abort
	if [[ ! "$ok" ]] ; then

	    # set error state
	    SSBHostInstallError=1

	    # show an alert
	    alert "Unable to install native messaging host. ($errmsg) The SSB will still work, but the companion \"Epichrome Helper\" extension won't." 'Messaging Host Install Error' '|caution'

	    # clear error state (non-fatal)
	    ok=1
	    errmsg=
	fi
    fi
fi


# UPDATE LINKS TO CHROME NATIVE MESSAGING HOSTS

if [[ "$ok" ]] ; then

    # link to hosts for both Chrome and Chromium
    googleChromeHostDir="${HOME}/Library/Application Support/Google/Chrome/NativeMessagingHosts"
    chromiumHostDir="${HOME}/Library/Application Support/Chromium/NativeMessagingHosts"

    # favor hosts from whichever browser our engine is using
    if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
	hostDirs=( "$chromiumHostDir" "$googleChromeHostDir" )
    else
	hostDirs=( "$googleChromeHostDir" "$chromiumHostDir" )
    fi

    # navigate to our host directory
    try '/dev/null&<' pushd "$hostInstallPath" "Unable to navigate to ${hostInstallPath}"

    # get list of host files currently installed
    hostFiles=( * )

    # remove dead host links
    for curFile in "${hostFiles[@]}" ; do
	if [[ -L "$curFile" && ! -e "$curFile" ]] ; then
	    try rm -f "$curFile" "Unable to remove dead link to $curFile."
	fi
    done

    # link to hosts from both directories
    for curHostDir in "${hostDirs[@]}" ; do

	if [[ -d "$curHostDir" ]] ; then

	    # get a list of all hosts in this directory
	    try '/dev/null&<' pushd "$curHostDir" "Unable to navigate to ${curHostDir}"
	    hostFiles=( * )
	    try '/dev/null&<' popd "Unable to navigate away from ${curHostDir}"

	    # link to any hosts that are not already in our directory
	    # or are links to a different file -- this way if a given
	    # host is in both the Chrome & Chromium directories, whichever
	    # we hit second will win
	    for curFile in "${hostFiles[@]}" ; do
		if [[ ( ! -e "$curFile" ) || \
			  ( -L "$curFile" && \
				! "$curFile" -ef "${curHostDir}/$curFile" ) ]] ; then
		    try ln -sf "${curHostDir}/$curFile" "$curFile" \
			"Unable to link to native messaging host ${curFile}."
		fi
	    done
	fi
    done

    try '/dev/null&<' popd "Unable to navigate away from ${hostInstallPath}."

    # errors here are non-fatal
    if [[ ! "$ok" ]] ; then
	alert "Warning: ${errmsg}." 'Unable to Link to Native Messaging Hosts' '|caution'
	ok=1
	errmsg=
    fi
fi


# STORE & TURN OFF FIRST-RUN STATUS

isFirstRun="$SSBFirstRun"
SSBFirstRun=

if [[ "$SSBFirstRunSinceVersion" ]] ; then

    # authenticate (fail to run otherwise)
    authenticate firstrun '' 'run for the first time'

    # update config file to signal no longer first run
    SSBFirstRunSinceVersion=
fi


# UPDATE CONFIG FILE IF NECESSARY

# $$$$ DELETE THIS AND ALL AUTHENTICATE CODE failsafe -- we should never get here without already authenticating
authenticate updateconfig '' 'update configuration'

# write out config file if anything has changed
writeconfig "$myContents"

[[ "$ok" ]] || abort "$errmsg" 1


# LAUNCH APP ENGINE

# export Google API keys for Chromium engine only
if [[ "$SSBEngineType" != "Google Chrome" ]] ; then
    export GOOGLE_API_KEY="AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k"
    export GOOGLE_DEFAULT_CLIENT_ID="811574891467.apps.googleusercontent.com"
    export GOOGLE_DEFAULT_CLIENT_SECRET="kdloedMFGdGla2P1zacGjAQh"
fi

# build command line
if [[ "$newprofile" ]] ; then
    # if we're creating a new profile (first run), run once with a page
    # instructing the user to enable the Epichrome extension
    myArgs=( "${argsOptions[@]}" "file://$myContents/Resources/FirstRun/welcome.html" )
else
    # normal run -- use the regular command line
    myArgs=( "${argsOptions[@]}" "${SSBCommandLine[@]}" )
fi

# engine is not running, so launch as usual (still sending URIs to engine)

try /usr/bin/open -a "$myEngineAppPath" "${argsURIs[@]}" --args "$myProfilePathArg" "${myArgs[@]}" \
	'Unable to launch app engine.'
[[ "$ok" ]] || abort

# find PID & launch cleanup process

sleep 0.5
getenginepid "$myEngineID" "$myEngineAppPath"

if [[ "$enginePID" ]] ; then

    # export debug & log options for cleanup daemon
    export debug logPreserve
    
    # PID found, so launch cleanup daemon
    try /usr/bin/open "$myContents/$appCleanupPath" --args \
	"$SSBEngineType" "$enginePID" "$myEngineAppPath" "$logPath" "$stderrTempFile" \
	'Unable to lauch cleanup helper. The app engine will not be properly cleaned up upon quitting.'

    [[ "$ok" ]] || alert "$errmsg" 'Warning' '|caution'

else

    # PID not found, display error message and quit
    [[ "$errmsg" ]] && errmsg="$errmsg "
    alert "${errmsg}Your app may not have launched properly. If it did, the engine will not be properly cleaned up upon quitting." 'Warning' '|caution'
fi
