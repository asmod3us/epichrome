#!/bin/sh
#
#  Epichrome: Run an Epichrome app
#  Copyright (C) 2019  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  Full license at: http://www.gnu.org/licenses/ (V3,6/29/2007)
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 


# DEBUG FLAG

debug=


# FUNCTION DEFINITIONS

# ABORT -- display an error alert and abort
function abort {
    alert "$1" "Unable to Run" '|stop'
    [[ "$2" ]] && exit $2
    exit 1
}

# UNSUDO -- run a command as the original user
function unsudo {
    if [[ "$isAdmin" ]] ; then
	sudo -u $USER "$@"
	local result="$?"
    else
	"$@"
	local result="$?"
    fi

    return "$result"
}


# RELAUNCH -- relaunch this app after a delay
function relaunch { # APP-PATH DELAY-SECONDS
    [[ "$2" ]] && sleep "$2"
    open "$1"
}


# AUTHENTICATE -- relaunch authenticated if necessary
isAuthenticated=
function authenticate {  # ID PREAMBLE MESSAGE NONFATAL (If NONFATAL exists, return 1 on auth fail)
    
    # only run if no error
    if [[ "$ok" ]]; then
	
	# get ID of this authentication to pass to self
	local id="$1"
	shift
	[[ "$id" ]] || id="admin"
	
	# build preamble
	local preamble="$1"
	shift
	[[ "$preamble" ]] && preamble="$preamble "
	
	# build alert message
	local msg="$1"
	shift
	[[ ! "$msg" ]] && msg="update"
	
	# get nonfatal argument
	local nonfatal="$1"
	
	# only check if we're not already authenticated
	if [[ ! "$isAuthenticated" ]] ; then
	    
	    # try to touch the app bundle--if we can, we have the privileges we need
	    cmdtext=$(/usr/bin/touch "$myPath" 2>&1)
	    
	    if [[ "$?" != 0 ]] ; then

		local doAuth=
		errre='Permission denied$'
		if [[ ! "$cmdtext" =~ $errre ]] ; then
		    
		    # some other error (not permission denied)
		    msg="Error attempting to determine if authentication is required."
		    
		    if [[ "$nonfatal" ]] ; then
			alert "$msg" 'Warning' '|caution'
		    else
			abort "$msg" 1
		    fi
		else
		    
		    # permission denied to touch this file--ask to authenticate
		    dialog doAuth "${preamble}In order to $msg, the app must run with administrator privileges." "Authentication Required" "|caution" "Authenticate" "+Cancel"
		    
		    # user wants to authenticate
		    if [[ "$doAuth" = "Authenticate" ]] ; then
			
			# replace ourself with an authenticated version
			#of the same script running with admin privileges
			#exec osascript -e 'do shell script "su -m '"$USER"' -c \"" & (quoted form of "'"${0//\"/\\\\\\\"}"'") & "\"" with administrator privileges'

			# add debug flag if it was set for us
			local debugOpt='""'
			[[ "$debug" ]] && debugOpt='" --debug "'
			    
			exec osascript -e 'do shell script (quoted form of "'"$0"'") & " --epichrome-admin " & $debugOpt & (quoted form of "'"$id"'") with administrator privileges'
			
		    elif [[ "$nonfatal" ]] ; then
			return 1
		    else
			abort "Please relaunch with administrator privileges." 1
		    fi
		fi
	    else
		isAuthenticated=1
	    fi
	fi
    fi
    
    # all went well, we are authenticated!
    [[ "$ok" ]] && return 0
    return 1
}


# LINKTREE: hard link to a directory or file
function linktree { # $1 = sourcedir (absolute)
    #                 $2 = destdir (absolute)
    #                 $3 = try error identifier
    #                 $@ = <files>

    if [[ "$ok" ]]; then
	
	# read arguments
	local sourcedir="$1"  # could absolutize: echo "$(cd "$foo" 2> /dev/null && pwd)"
	local destdir="$2"
	local tryid="$3"
	shift 3

	# make sure both directories are on the same filesystem
	local sourceDevice=
	try 'sourceDevice=' /usr/bin/stat -f '%d' "$sourcedir" \
	    "Unable to get info on $sourcedir."
	local destDevice=
	try 'destDevice=' /usr/bin/stat -f '%d' "$destdir" \
	    "Unable to get info on $destdir."
	
	if [[ "$ok" ]] ; then
	    if [[ "$sourceDevice" != "$destDevice" ]]; then
		ok=
		errmsg="$entry must be on the same drive as this app."
	    fi
	fi

	if [[ "$ok" ]] ; then
	    # pushd to source directory
	    try '/dev/null&<' pushd "$sourcedir" \
		"$tryid link error: Unable to move to $sourcedir"

	    local files=
	    if [[ "$@" ]] ; then
		files=( "$@" )
	    else
		# no items specified, so link all non-dot items
		files=( * )
	    fi
	    
	    # loop through entries creating hard links
	    for entry in "${files[@]}" ; do
		# hard link
		try /bin/pax -rwlpp "$entry" "$destdir" \
		    "$tryid link error: Unable to create link to $entry."
	    done
	    
	    # popd back from source directory
	    try '/dev/null&<' popd \
		"$tryid link error: Unable to move back from $sourcedir."
	fi
    fi
}


# GETENGINEPID: get the PID of the running engine
enginePID=
function getenginepid { # ENGINE-BUNDLE-ID ENGINE-BUNDLE-PATH

    # assume no PID
    enginePID=
    
    # args
    local id="$1"
    local path="$2"
    
    # get all ASNs associated with the engine's bundle ID
    local asns=
    try 'asns=()' /usr/bin/lsappinfo find "bundleid=$id" \
	'Error while attempting to find running engine.'
    
    # no engine found, just don't return a PID
    if [[ "$ok" && ( "${#asns[@]}" = 0 ) ]] ; then
	return 0
    fi
    
    # search for PID
    if [[ "$ok" ]] ; then

	local info=
	
	local a=
	for a in "${asns[@]}" ; do

	    # get info on an ASN (we use try for the debugging output)
	    try 'info=' /usr/bin/lsappinfo info "$a" ''
	    ok=1 ; errmsg=
	    
	    # if this ASN matches our bundle, grab the PID
	    re='bundle path *= *"([^'$'\n'']+)".*pid *= *([0-9]+)'
	    if [[ ( "$info" =~ $re ) && ( "${BASH_REMATCH[1]}" = "$path" ) ]] ; then
		enginePID="${BASH_REMATCH[2]}"
		break
	    fi

	    # not found, so reset info
	    info=
	done
    fi

    # return result
    if [[ "$enginePID" ]] ; then
	ok=1 ; errmsg=
	return 0
    elif [[ "$ok" ]] ; then
	return 0
    else
	# errors in this function are nonfatal; just return the error message
	ok=1
	return 1
    fi
}


# CLEANUP: wait for app engine to die, then clean it up
function cleanup {  # $1 = ENGINE-PID
    
    # wait for app to exit
    while /bin/kill -0 "$1" 2> /dev/null ; do
	sleep 1
    done
    
    # make sure we can still find engine
    if [[ ! -d "$myEngineAppContents" ]] ; then
	# abort -- something has gone wrong, maybe app was renamed or moved
	echo "Cleanup error: Can't find app engine." 1>&2
	exit 1
    fi
    
    # build list of runtime elements to delete

    local deletelist=()
    local curdir=
    local i=

    # all items in engine root except Contents
    dirlist "$SSBEngineAppPath" curdir 'app engine' '^Contents$'
    for i in "${curdir[@]}" ; do
	deletelist+=( "$SSBEngineAppPath/$i" )
    done
    
    if [[ "$SSBEngineType" != 'Google Chrome' ]] ; then
	# all items in Contents except Info.plist, MacOS & Resources
	dirlist "$myEngineAppContents" curdir \
		'Epichrome app engine Contents' \
		'^((Info.plist)|(MacOS)|(Resources))$'
    else
	# all items in Contents except MacOS & Resources
	dirlist "$myEngineAppContents" curdir \
		'Google Chrome app engine Contents' \
		'^((MacOS)|(Resources))$'
    fi
    for i in "${curdir[@]}" ; do
	deletelist+=( "$myEngineAppContents/$i" )
    done

    # all items in Resources except .lproj & .icns
    dirlist "$myEngineAppContents/Resources" curdir \
	    'app engine Resources' '\.((icns)|(lproj))$'
    for i in "${curdir[@]}" ; do
	deletelist+=( "$myEngineAppContents/Resources/$i" )
    done

    # delete items
    if [[ "${deletelist[*]}" ]] ; then
	try /bin/rm -rf "${deletelist[@]}" \
	    'Unable to clean up app engine.'
    fi

    # report any errors with the deletion process
    if [[ ! "$ok" ]] ; then
	ok=1
	echo "Cleanup error: $errmsg" 1>&2
    fi
    
    # Chromium engine: rename Info.plist Info.plist.off
    if [[ "$SSBEngineType" != "Google Chrome" ]] ; then
	try /bin/mv -f "$myEngineAppContents/Info.plist" \
	    "$myEngineAppContents/Info.plist.off" \
	    'Unable to deactivate payload Info.plist.'
	if [[ ! "$ok" ]] ; then
	    ok=1
	    echo "Cleanup error: $errmsg" 1>&2
	fi
    fi
    
    # rename engine back to Payload
    try /bin/mv -f "$SSBEngineAppPath" "$myPayloadPath" \
	'Unable to restore Payload directory.'

    # report any final error
    if [[ ! "$ok" ]] ; then
	echo "Cleanup error: $errmsg" 1>&2
	exit 1
    fi
    
    exit 0
}


# MAIN BODY


# PARSE COMMAND-LINE OPTIONS

isAdmin=
argsURIs=()
argsOptions=()
while [[ "$#" -gt 0 ]] ; do
    case "$1" in
        --epichrome-admin)
	    isAdmin="$1"
            ;;
        
        --epichrome-debug)
            debug=1
            ;;
	
	[hH][tT][tT][pP]'://'*|[hH][tT][tT][pP][sS]'://'*|[fF][tT][pP]'://'*|[fF][iI][lL][eE]'://'*)
	    # this should be sent to the open command
	    argsURIs+=( "$1" )
	    ;;
	
	*)
	    # pass any other options along to the engine
	    argsOptions+=( "$1" )
    esac

    # get next arg
    shift
done


# BOOTSTRAP RUNTIME SCRIPT

# determine location of runtime script
myPath=$(cd "$(dirname "$0")/../.."; pwd)
myContents="$myPath/Contents"
[[ $? != 0 ]] && abort 'Unable to determine app path.' 1
[[ "$myPath" =~ \.[aA][pP][pP]$ ]] || abort 'Unexpected app path.' 1

# load main runtime functions
source "${myContents}/Resources/Scripts/runtime.sh"
[[ $? != 0 ]] && abort 'Unable to load runtime script.' 1


# GET BASIC APP INFORMATION

# load config.sh file
readconfig


# SET UP USER PROFILE PATH

# get absolute profile path
myProfilePath="${HOME}/$SSBProfilePath"
myProfileArg="--user-data-dir=$myProfilePath"

# override runtime.sh debug log path & start fresh
debugLogPath="$myProfilePath/_epichrome_log.txt"
/bin/rm -f "$debugLogPath"

# by default, use existing profile
newprofile=


# IF THE ENGINE IS ALREADY RUNNING, SEND ANY FILES TO RUNNING ENGINE & QUIT

# get the ID of the engine app
if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
    myEngineID="$googleChromeID"
else
    myEngineID="${appEngineIDBase}.${SSBIdentifier}"
fi

# determine if the engine is running
getenginepid "$myEngineID" "$SSBEngineAppPath"
if [[ "$?" != 0 ]] ; then
    debuglog "Unable to determine if app engine is running: $errmsg"
fi

if [[ "$enginePID" ]] ; then
    
    # engine is already running, so just send any files or URLs to it &
    # don't run the usual command-line

    if [[ "$SSBEngineType" = "Google Chrome" ]] ; then

	# Google Chrome engine, open by engine path
	try "$SSBEngineAppPath/Contents/MacOS/$SSBGoogleChromeExec" "$myProfileArg" "${argsURIs[@]}" \
	    'Unable to connect to running Google Chrome app engine.'
    else
	
	# Chromium engine, open by engine ID
	try /usr/bin/open -b "$myEngineID" "${argsURIs[@]}" \
	    'Unable to connect to app engine.'
    fi
    
    # we're done, so exit
    [[ "$ok" ]] && exit 0
    exit 1
fi


# ENGINE IS NOT RUNNING, SO GATHER MORE INFO

if [[ "$SSBEngineType" = "Google Chrome" ]] ; then

    # get info on the installed Google Chrome
    googlechromeinfo
fi

# abort on error
[[ "$ok" ]] || abort "$errmsg" 1


# CHECK FOR NEW VERSION OF EPICHROME AND UPDATE

# get info on current Epichrome version
epichromeinfo
if [[ ! "$ok" ]] ; then
    # fail silently, and we just won't check for updates
    ok=1 ; errmsg=
fi

if [[ "$(newversion "$SSBVersion" "$epiVersion")" ]] ; then

    # authenticate
    authenticate epichromeupdate "A new version of the Epichrome runtime was found ($epiVersion)." \
		 'update' nonfatal
    if [[ "$?" = 0 ]] ; then
	
	# Ask about updating (unless we asked with the authentication dialog)
	if [[ "$isAdmin" != epichromeupdate ]] ; then
	    dialog doUpdate \
		   "A new version of the Epichrome runtime was found ($epiVersion). Would you like to update now?" \
		   "Update" \
		   "|caution" \
		   "+Update" \
		   "-Later" \
		   "Don't Ask Again For This Version"
	    if [[ ! "$ok" ]] ; then
		alert "A new version of the Epichrome runtime was found ($epiVersion) but the update dialog failed. Attempting to update now." 'Update' '|caution'
		doUpdate="Update"
		ok=1
		errmsg=
	    fi
	else
	    doUpdate="Update"
	fi
	
	if [[ "$ok" ]] ; then
	    
	    # act based on dialog
	    case "$doUpdate" in
		Update)
		    
		    # read in the new runtime
		    safesource "$epiContents/Resources/Runtime/Resources/Scripts/runtime.sh" "updated runtime script"
		    
		    # use new runtime to update the SSB (and relaunch)
		    updateapp "$myPath"
		    
		    # relaunch after a delay
		    if [[ "$ok" ]] ; then
			relaunch "$myPath" 1 &
			disown -ar
			exit 0
		    fi
		    ;;
		
		Later)
		    # don't update
		    doUpdate=
		    ;;
		
		*)
		    # pretend we're already at the new version
		    SSBVersion="$epiVersion"
		    ;;
	    esac
	fi
	
	# alert the user to any error, but don't abort
	if [[ ! "$ok" ]] ; then
	    alert "$errmsg Please try update again later." 'Unable to Update' '|caution'
	    ok=1
	    errmsg=
	fi
    fi
fi


# CHECK FOR A NEW VERSION OF EPICHROME ON GITHUB

try 'curDate=' /bin/date '+%s' 'Unable to get date for Epichrome update check.'
if [[ "$ok" ]] ; then
    
    # check for updates if we've never run a check, or if the next check date is in the past
    if [[ ( ! "$SSBUpdateCheckDate" ) || ( "$SSBUpdateCheckDate" -lt "$curDate" ) ]] ; then

	# set next update for 7 days from now
	SSBUpdateCheckDate=$(($curDate + (7 * 24 * 60 * 60)))
	
	# if we haven't set a version to check against, use the current version
	[[ "$SSBUpdateCheckVersion" ]] || SSBUpdateCheckVersion="$epiVersion"

	# check if there's a new version on Github
	try 'updateResult=' checkepichromeversion "$myContents" "$SSBUpdateCheckVersion" 'Unable to check for a new version of Epichrome on Github.'
	if [[ ! "$ok" ]] ; then
	    alert "Warning: $errmsg" 'Checking For Update' '|caution'
	    ok=1
	else

	    # if there's an update available, display a dialog
	    if [[ "$updateResult" ]] ; then
		# set separator to newline
		oldifs="$IFS"
		IFS=$'\n'

		# convert result into an array
		updateResult=( $(echo "$updateResult") )

		# display dialog
		dialog doEpichromeUpdate \
		   "A new version of Epichrome (${updateResult[0]}) is available on GitHub." \
		   "Update Available" \
		   "|caution" \
		   "+Download" \
		   "-Later" \
		   "Ignore This Version"
		
		# act based on dialog
		if [[ "$ok" ]] ; then
		    
		    case "$doEpichromeUpdate" in
			Download)
			    # open the update URL
			    open "${updateResult[1]}"
			    ;;
			
			Later)
			    # do nothing
			    doEpichromeUpdate=
			    ;;
			*)
			    # pretend we're already at the new version
			    SSBUpdateCheckVersion="${updateResult[0]}"
			    ;;
		    esac
		fi
		
		# alert the user to any error, but don't abort
		if [[ ! "$ok" ]] ; then
		    alert "Warning: $errmsg" 'Checking For Update' '|caution'
		    ok=1
		fi
		
		IFS="$oldifs"
	    fi
	fi
    fi
fi


# IF USING GOOGLE CHROME ENGINE, CHECK FOR NEW VERSION AND UPDATE

if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
    
    if [[ "$SSBGoogleChromeVersion" != "$configSSBGoogleChromeVersion" ]] ; then
	
	# authenticate
	authenticate chromeupdate "A new version of Google Chrome was found ($SSBGoogleChromeVersion)." \
		     'update' nonfatal
	if [[ "$?" = 0 ]] ; then
	    
	    # create a new engine payload from the new version
	    createenginepayload "$myContents"
	else
	    ok=
	    errmsg="Permission denied."
	fi
	
	# failure is non-fatal
	if [[ ! "$ok" ]] ; then
	    abort "Unable to update app to new version of Google Chrome. ($errmsg)" 1
	fi
    fi
fi

[[ "$ok" ]] || abort "$errmsg" 1


# BUILD ENGINE ON THE FLY

# get important absolute paths
myEnginePath="$myContents/$appEngine"
myPayloadPath="$myContents/$appPayload"
myPayloadContents="$myPayloadPath/Contents"

# RECREATE PAYLOAD IF NECESSARY

# status variable to decide if we need to recreate the payload
newPayload=

# no payload directory found or missing key items
if [[ ( ! -d "$myPayloadPath" ) || ( ! -d "$myPayloadPath/Resources" ) ]] ; then
    newPayload=1
else
    # check for corrupt Payload directory

    # get manifest of current Payload directory
    payloadManifest="$(cd "$myPayloadPath" && /usr/bin/find -L . -print | /usr/bin/sort)"
    if [[ "$?" != 0 ]] ; then
	debuglog "Failed to get manifest of payload directory."
	newPayload=1
    else
	if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
	    # get Google Chrome payload manifest
	    engineManifest="$(cd "$SSBGoogleChromePath" && /usr/bin/find -L . -path '.' -print -or -path './Contents' -print -or -path './Contents/Resources' -print -or -path './Contents/Resources*' -path '*.lproj*' -not -path './Contents/*/Contents/*' -print -or -path './Contents/Resources/*.icns' -print | /usr/bin/sort)"
	    if [[ "$?" != 0 ]] ; then
		debuglog "Failed to get manifest of Google Chrome directory."
		newPayload=1
	    fi
	else
	    # get Epichrome Chromium payload manifest
	    engineManifest="$(cd "$epiPayload" && (echo './Contents/Resources/app.icns' && echo './Contents/Resources/document.icns' && /usr/bin/find -L . -print) | /usr/bin/sed -E -e 's/InfoPlist\.strings.in/InfoPlist.strings/' -e 's/Info.plist.in/Info.plist.off/' | /usr/bin/sort)"
	    if [[ "$?" != 0 ]] ; then
		debuglog "Failed to get manifest of Epichrome payload directory."
		newPayload=1
	    fi
	fi

	if [[ "$payloadManifest" != "$engineManifest" ]] ; then
	    debuglog "App payload doesn't match engine source payload."
	    newPayload=1
	fi	
    fi
fi

# create a new engine payload if needed
[[ "$newPayload" ]] && createenginepayload "$myContents"


# UPDATE ENGINE APP NAME & PATH

# regex for pulling out current app name
appNameRe='/([^/]+)\.[aA][pP][pP](\.[0-9]+)?$'

# try to use current name of this Epichrome app as engine name
if [[ "$myPath" =~ $appNameRe ]] ; then
    SSBEngineAppName="${BASH_REMATCH[1]}.app"
else
    # if app name is unparsable, just use Info.plist display name
    SSBEngineAppName="${CFBundleDisplayName}.app"
fi

# get paths for engine app bundle
SSBEngineAppPath="$myEnginePath/$SSBEngineAppName"
myEngineAppContents="$SSBEngineAppPath/Contents"


# BUILD ENGINE OUT OF PAYLOAD

# rename Payload to engine app name
try /bin/mv "$myPayloadPath" "$SSBEngineAppPath" 'Unable to create app engine from payload.'

[[ "$ok" ]] || abort "$errmsg" 1

if [[ "$SSBEngineType" != "Google Chrome" ]] ; then
    
    # EPICHROME CHROMIUM ENGINE

    # link to everything except Resources directory
    dirlist "$epiEngineRuntime" curdir 'Epichrome app engine' '^Resources$'
    linktree "$epiEngineRuntime" "$myEngineAppContents" \
	     'Epichrome app engine' "${curdir[@]}"
    
    # link to everything in Resources
    linktree "$epiEngineRuntime/Resources" "$myEngineAppContents/Resources" \
	     'Epichrome app engine Resources'
else
    # GOOGLE CHROME ENGINE
    
    # link to everything except Resources & MacOS directories
    dirlist "$googleChromeContents" curdir \
	    'Google Chrome app engine' '^((Resources)|(MacOS))$'
    linktree "$googleChromeContents" "$myEngineAppContents" \
	     'Google Chrome app engine' "${curdir[@]}"
    
    # link to everything in Resources except .lproj & .icns
    dirlist "$googleChromeContents/Resources" curdir \
	    'Google Chrome app engine Resources' '\.((icns)|(lproj))$'
    linktree "$googleChromeContents/Resources" "$myEngineAppContents/Resources" \
	     'Google Chrome app engine Resources' \
	     "${curdir[@]}"    
fi
    
# abort on error
[[ "$ok" ]] || abort "$errmsg" 1


# HANDLE FIRST-RUN SETUP

if [[ "$SSBFirstRunSinceVersion" ]]; then

    # UPDATE PROFILE PATH
    
    # check if we're migrating profile paths
    if [[ "$(isarray SSBProfilePath)" ]] ; then
	
	# get old path info
	oldProfilePath="${SSBProfilePath[1]}"
	
	# get absolute path if necessary
	[[ "${oldProfilePath:0:1}" = "/" ]] || oldProfilePath="${HOME}/$oldProfilePath"

	# get the base directory
	oldProfileBase="${oldProfilePath%/*}"
	
	# if there's a profile in the old location, try to move it
	if [[ -d "$oldProfilePath" ]] ; then
	    if [[ -e "$myProfilePath" && ! -d "$myProfilePath" ]]; then
		# found something other than a directory, get rid of it
		try rm -f "$myProfilePath" 'Unable to clean up new profile location.'
		[[ "$ok" ]] || abort "Can't create profile folder. $errmsg" 1
	    fi
	    
	    if [[ ! -d "$myProfilePath" ]]; then
		
		# old profile exists, new one doesn't, so create it
		newprofile=1
		try 'profileBase=' dirname "$myProfilePath" \
		    'Unable to get path to profile folder.'
		try unsudo mkdir -p "$profileBase" \
		    'Unable to create profile folder.'
		try mv -f "$oldProfilePath" "$myProfilePath" \
		    'Unable to move profile folder from old location.'
		if [[ ! "$ok" ]] ; then
		    alert "Warning: $errmsg You may lose your settings." \
			  'Updating Profile' '|caution'
		    ok=1
		fi
	    else
		# profile directories in both places! throw up hands
		alert 'Warning: Profiles exist in both new and old locations. Your old profile will be ignored.' 'Multiple Profiles' '|caution'
	    fi
	fi
	
	# if we've emptied out the old profile base folder, get rid of it (not important, so fail silently)
	rm -f "${oldProfileBase}/.DS_Store" > /dev/null 2>&1
	foob="$(rmdir "$oldProfileBase"  2>&1)"
	
	# update profile path to be a single entry now that we're done migrating
	tempProfilePath="${SSBProfilePath[0]}"
	unset SSBProfilePath
	SSBProfilePath="$tempProfilePath"
    fi
fi


# CREATE PROFILE FOLDER IF IT DOESN'T ALREADY EXIST

# create profile folder   $$$ REMOVE UNSUDO ON DEAUTH PASS??
if [[ ! -d "$myProfilePath" ]]; then
    newprofile=1
    try unsudo mkdir -p "$myProfilePath" 'Unable to create profile folder.'
    [[ "$ok" ]] || abort "$errmsg" 1
fi

# $$$ GET RID OF THIS AND USE MASTER PREFS?? OR REMOVE UNSUDO
# set First Run file so Chrome doesn't think it's new (fail silently)
firstrunfile="${myProfilePath}/First Run"
[[ -e "$firstrunfile" ]] || unsudo touch "$firstrunfile" > /dev/null 2>&1


# MOVE EXTENSION-INSTALLATION SCRIPT INTO PLACE

extDoCopy=
if [[ "$SSBFirstRunSinceVersion" || "$newprofile" ]]; then
    
    # set up useful variables
    extDir="External Extensions"
    extSourcePath="$myContents/Resources/$extDir"
    extDestPath="$myProfilePath/$extDir"
    
    # make sure the extension install source folder exists
    if [[ ! -d "$extSourcePath" ]] ; then
	ok=
	errmsg='No source directory found.'
    fi
    
    # get a listing of the source directory
    dirlist "$extSourcePath" extSourceList 'source directory'
    
    # check if the source directory is empty
    if [[ "$ok" && ( ! "${extSourceList[*]}" ) ]]; then
	ok=
	errmsg='The source directory is empty.'
    fi
    
    # check if the destination directory exists
    if [[ "$ok" ]] ; then
	if [[ -e "$extDestPath" && ! -d "$extDestPath" ]]; then
	    # found something other than a directory, get rid of it
	    try rm -f "$extDestPath" 'Unable to clean up destination directory.'
	fi
	
	if [[ "$ok" && ! -d "$extDestPath" ]] ; then
	    # no destination directory
	    extDoCopy=1
	else
	    # get a listing of the destination directory
	    dirlist "$extDestPath" extDestList 'destination directory'
	    
	    # compare source and destination directories
	    if [[ "$ok" && ( "${extSourceList[*]}" != "${extDestList[*]}" ) ]] ; then
		extDoCopy=1
	    fi
	fi
    fi
    
    # $$$$ REMOVE UNSUDO??
    # if for any reason we need to copy the install directory, do it now
    if [[ "$ok" && "$extDoCopy" ]] ; then
	unsudo safecopy "$extSourcePath" "$extDestPath" 'installation directory'
    fi
    
    # report error, but don't abort
    if [[ ! "$ok" ]] ; then
	# show warning alert
	alert "Can't install \"Epichrome Helper\" extension. ($errmsg) Your app will still work, but if you want to use the extension, you'll have to install it manually." 'Extension Install Error' '|caution'

	# clear extension copy state
	extDoCopy=
	
	# clear error state
	ok=1 ; errmsg=
    fi
fi


# MAKE SURE NATIVE HOST IS INSTALLED

if [[ ! "$SSBHostInstallError" ]]; then
    
    # set up host file paths
    hostManifest=( "org.epichrome.runtime.json" "org.epichrome.helper.json" )
    hostScript="epichromeruntimehost.py"
    hostDir="NativeMessagingHosts"
    hostInstallPath="$myProfilePath/$hostDir"
    hostScriptInstalled="$hostInstallPath/$hostScript"
    hostManifestInstalled=( "$hostInstallPath/${hostManifest[0]}" "$hostInstallPath/${hostManifest[1]}" )
    
    # check if we need to install native messaging host
    doHostInstall=
    
    # do it if we just updated, or the host script or manifest don't exist
    if [[ "$SSBFirstRunSinceVersion" || \
	      ( ! -x "$hostScriptInstalled" ) || \
	      ( ! -e "${hostManifestInstalled[0]}" ) || \
	      ( ! -e "${hostManifestInstalled[1]}" ) ]] ; then
	doHostInstall=1
    else
	# get installed host version if possible
	try 'hostVersion=' "$hostScriptInstalled" -v ''
	if [[ ! "$ok" ]] ; then
	    hostVersion=0.0.0
	    ok=1 ; errmsg=
	fi
	
	# if installed host is old, we'll update it
	[[ $(newversion "$hostVersion" "$epiVersion") ]] && doHostInstall=1
    fi
    
    # make sure the manifest points to the current path of the script
    if [[ ! "$doHostInstall" ]] ; then
	
	for hmi in "${hostManifestInstalled[@]}" ; do
	    
	    # get path to script in the manifest
	    try 'oldHostScriptInstalled=' sed -En \
		's/^.*"path": "(.*)",[ ]*(\/\/.*)?$/\1/p' "$hmi" \
		'Unable to get current host script path'
	    
	    # on error, or if the paths don't match, reinstall
	    if [[ ! "$ok" || \
		      ("$oldHostScriptInstalled" != "$hostScriptInstalled") ]] ; then
		ok=1 ; errmsg=
		doHostInstall=1
	    fi
	    
	done
    fi
    
    # do the installation if necessary
    if [[ "$doHostInstall" ]] ; then
	
	hostSourcePath="$myContents/Resources/$hostDir"
	
	# create the install directory
	try unsudo /bin/mkdir -p "$hostInstallPath" \
	    'Unable to create installation folder.'
	
	# stream-edit the host script  $$$ UNSUDO
	hostScriptTmp=$(tempname "$hostScriptInstalled")
	try unsudo /usr/bin/touch "${hostScriptTmp}" \
	    'Unable to create script.'
	try "${hostScriptTmp}<" sed \
	    "s/APPBUNDLEID/${appIDBase}.${SSBIdentifier}/; s/APPDISPLAYNAME/$CFBundleDisplayName/; s/APPBUNDLENAME/$CFBundleName/;" \
	    "$hostSourcePath/$hostScript" 'Unable to copy script.'
	
	# fix host script permissions
	try /bin/chmod 755 "$hostScriptTmp" 'Unable to make script executable.'
	
	# move script to permanent home
	permanent "$hostScriptTmp" "$hostScriptInstalled" 'script'

	# on error, remove temporary file
	if [[ ! "$ok" ]] ; then
	    [[ -e "$hostScriptTmp" ]] && rmtemp "$hostScriptTmp" 'script'
	fi

	index=0
	for hmi in "${hostManifestInstalled[@]}" ; do
	    
	    # stream-edit the manifest file
	    hostManifestTmp=$(tempname "$hmi")
	    try unsudo /usr/bin/touch "${hostManifestTmp}" \
		'Unable to create manifest.'
	    try "${hostManifestTmp}<" sed \
		"s/APPHOSTPATH/${hostScriptInstalled//\//\\/}/" \
		"$hostSourcePath/${hostManifest[$index]}" \
		'Unable to copy manifest.'
	    
	    # move manifest to permanent home
	    permanent "$hostManifestTmp" "$hmi" 'manifest'
	    
	    # on error, remove temporary file
	    if [[ ! "$ok" ]] ; then
		[[ -e "$hostManifestTmp" ]] && \
		    rmtemp "$hostManifestTmp" 'manifest'
	    fi
	    
	    index=$(($index + 1))
	done
	
	# report error, but don't abort
	if [[ ! "$ok" ]] ; then
	    
	    # set error state
	    SSBHostInstallError=1
	    
	    # show an alert
	    alert "Unable to install native messaging host. ($errmsg) The SSB will still work, but the companion \"Epichrome Helper\" extension won't." 'Messaging Host Install Error' '|caution'
	    
	    # clear error state (non-fatal)
	    ok=1
	    errmsg=
	fi
    fi
fi


# UPDATE LINKS TO CHROME NATIVE MESSAGING HOSTS

if [[ "$ok" ]] ; then

    # link to hosts for both Chrome and Chromium
    googleChromeHostDir="${HOME}/Library/Application Support/Google/Chrome/NativeMessagingHosts"
    chromiumHostDir="${HOME}/Library/Application Support/Chromium/NativeMessagingHosts"

    # favor hosts from whichever browser our engine is using
    if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
	hostDirs=( "$chromiumHostDir" "$googleChromeHostDir" )
    else
	hostDirs=( "$googleChromeHostDir" "$chromiumHostDir" )
    fi
    
    # navigate to our host directory
    try '/dev/null&<' pushd "$hostInstallPath" "Unable to navigate to ${hostInstallPath}"
    
    # get list of host files currently installed
    hostFiles=( * )	
    
    # remove dead host links    
    for curFile in "${hostFiles[@]}" ; do
	if [[ -L "$curFile" && ! -e "$curFile" ]] ; then
	    try rm -f "$curFile" "Unable to remove dead link to $curFile."
	fi
    done

    # link to hosts from both directories
    for curHostDir in "${hostDirs[@]}" ; do
	
	if [[ -d "$curHostDir" ]] ; then
	    
	    # get a list of all hosts in this directory
	    try '/dev/null&<' pushd "$curHostDir" "Unable to navigate to ${curHostDir}"
	    hostFiles=( * )
	    try '/dev/null&<' popd "Unable to navigate away from ${curHostDir}"
	    
	    # link to any hosts that are not already in our directory
	    # or are links to a different file -- this way if a given
	    # host is in both the Chrome & Chromium directories, whichever
	    # we hit second will win
	    for curFile in "${hostFiles[@]}" ; do
		if [[ ( ! -e "$curFile" ) || \
			  ( -L "$curFile" && \
				! "$curFile" -ef "${curHostDir}/$curFile" ) ]] ; then
		    try ln -sf "${curHostDir}/$curFile" "$curFile" \
			"Unable to link to native messaging host ${curFile}."
		fi
	    done
	fi
    done
    
    try '/dev/null&<' popd "Unable to navigate away from ${hostInstallPath}."
    
    # errors here are non-fatal
    if [[ ! "$ok" ]] ; then
	alert "Warning: ${errmsg}." 'Unable to Link to Native Messaging Hosts' '|caution'
	ok=1
	errmsg=
    fi
fi


# STORE & TURN OFF FIRST-RUN STATUS

isFirstRun="$SSBFirstRun"
SSBFirstRun=

if [[ "$SSBFirstRunSinceVersion" ]] ; then

    # authenticate (fail to run otherwise)
    authenticate firstrun '' 'run for the first time'
    
    # update config file to signal no longer first run
    SSBFirstRunSinceVersion=
fi


# UPDATE CONFIG FILE IF NECESSARY

# $$$$ DELETE THIS AND ALL AUTHENTICATE CODE failsafe -- we should never get here without already authenticating
authenticate updateconfig '' 'update configuration'

# write out config file if anything has changed
writeconfig "$myContents"

[[ "$ok" ]] || abort "$errmsg" 1


# LAUNCH APP ENGINE

# export Google API keys for Chromium engine only
if [[ "$SSBEngineType" != "Google Chrome" ]] ; then
    export GOOGLE_API_KEY="AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k"
    export GOOGLE_DEFAULT_CLIENT_ID="811574891467.apps.googleusercontent.com"
    export GOOGLE_DEFAULT_CLIENT_SECRET="kdloedMFGdGla2P1zacGjAQh"
fi

# build command line
if [[ "$newprofile" ]] ; then
    # if we're creating a new profile (first run), run once with a page
    # instructing the user to enable the Epichrome extension
    myArgs=( "${argsOptions[@]}" "file://$myContents/Resources/FirstRun/welcome.html" )
else
    # normal run -- use the regular command line
    myArgs=( "${argsOptions[@]}" "${SSBCommandLine[@]}" )
fi

# engine is not running, so launch as usual (still sending URIs to engine)

if [[ "$SSBEngineType" = "Google Chrome" ]] ; then

    # Google Chrome engine, launch by engine app path
    try /usr/bin/open -a "$SSBEngineAppPath" "${argsURIs[@]}" --args "$myProfileArg" "${myArgs[@]}" \
	'Unable to launch Google Chrome app engine.'
    
else

    # Chromium engine, use open to launch engine
    
    try /usr/bin/open -b "$myEngineID" "${argsURIs[@]}" --args "$myProfileArg" "${myArgs[@]}" \
	'Unable to launch app engine.'
fi

[[ "$ok" ]] || abort "$errmsg" 1

# find PID & launch cleanup process

#sleep 0.5
getenginepid "$myEngineID" "$SSBEngineAppPath"

if [[ "$enginePID" ]] ; then
    
    # PID found, so launch cleanup daemon
    try /usr/bin/open "$myContents/$appCleanup" --args "$SSBEngineType" "$enginePID" "$SSBEngineAppPath" \
	'Unable to lauch cleanup helper. The app engine will not be properly cleaned up upon quitting.'
    
    [[ "$ok" ]] || alert "$errmsg" 'Warning' '|caution'
    
else
    
    # PID not found, display error message and quit
    [[ "$errmsg" ]] && errmsg="$errmsg "
    alert "${errmsg}Your app may not have launched properly. If it did, the engine will not be properly cleaned up upon quitting." 'Warning' '|caution'
fi
