#!/bin/sh
#
#  Epichrome: Run an Epichrome app
#
#  Copyright (C) 2020  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  Full license at: http://www.gnu.org/licenses/ (V3,6/29/2007)
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# BUILD FLAGS

debug=
logPreserve=
export debug logPreserve


# CORE APP INFO (FILLED IN BY UPDATEAPP)

SSBIdentifier=APPID
SSBVersion=APPVERSION
SSBEngineType=APPENGINETYPE
CFBundleDisplayName=APPDISPLAYNAME
CFBundleName=APPBUNDLENAME
SSBCommandLine=APPCOMMANDLINE
export SSBIdentifier SSBVersion SSBEngineType CFBundleDisplayName CFBundleName SSBCommandLine


# FUNCTION DEFINITIONS


# CLEANUP -- release any lock we've set
function cleanup {
    lockrelease
}


# LOCK FUNCTIONS

# (do NOT export these -- they should not be inherited)
lockOn=
lockPID=
lockEnginePID=

# LOCKSET -- set a lock file, or fail if it's already set
function lockset { # ( [ myLockEnginePID ] )
    
    if [[ "$ok" ]] ; then
	
	# extra info for the lock
	local myLockEnginePID="$1" ; shift

	# error: lock variable is already set
	if [[ "$lockOn" ]] ; then
	    errmsg='Lock variable is already set.'
	    ok=
	    return 1
	fi
	
	# check if there's already a lock file in place    
	if [[ -f "$myLockFile" ]] ; then
	    
	    # read the existing lock file
	    safesource "$myLockFile" 'lock'
	    [[ "$ok" ]] || return 1
	    
	    if [[ "$lockPID" = "$$" ]] ; then
		
		# error: this is already our lock
		errmsg='Lock is already set.'
		ok=
		return 1
		
	    else
		
		# we're not replacing this lock, so if the lock PID is still alive, we fail
		kill -0 "$lockPID" 2> /dev/null && return 1
	    fi
	fi
	
	# if we got here, there's either no lock, or we can stomp on an old one
	lockPID="$$" ; lockEnginePID="$myLockEnginePID"
	writevars "$myLockFile" lockPID lockEnginePID
	[[ "$ok" ]] || return 1
	
	# return success
	lockOn=1
	return 0
    fi
    
    return 1
}


# LOCKRELEASE -- release a lock file
function lockrelease {

    if [[ "$lockOn" ]] ; then

	# release lock variable
	lockOn=

	if [[ -f "$myLockFile" ]] ; then
	    
	    # command to delete lock file
	    local myCommand=( /bin/rm -f "$myLockFile" )

	    if [[ "$ok" ]] ; then
		
		try "${myCommand[@]}" 'Unable to delete old lock file.'
		
		# error is non-fatal: log error message, then clear error
		if [[ ! "$ok" ]] ; then
		    errlog "$errmsg"
		    ok=1 ; errmsg=
		fi
		
	    else
		tryonerr "${myCommand[@]}" 'Also unable to delete old lock file.'
	    fi
	    
	    return 0
	else
	    # no lock file found
	    return 1
	fi
	
    else
	
	# no lock set
	return 1
    fi
}

# export lock functions
export -f lockset lockrelease


# MAIN BODY


# LOAD CORE SCRIPT

# set log ID
logApp="$SSBIdentifier[Launch]"

# load core
source "${BASH_SOURCE[0]%/*}/Scripts/core.sh" app "$myAppPath"
if [[ "$?" != 0 ]] ; then
    [[ ! "$myLogFile" ]] && myLogFile="$HOME/Library/Application Support/Epichrome/Apps/$SSBIdentifier/epichrome_app_log.txt"
    /bin/mkdir -p "${myLogFile%/*}"
    echo 'Unable to load core script.' >> "$myLogFile"
    exit 1
fi
[[ "$ok" ]] || abort


# HANDLE KILL SIGNALS

function handleexitsignal {
    if [[ "$lockOn" ]] ; then
	errlog 'Terminated prematurely. Cleaning up.'
	lockrelease
    fi
}
trap '' INT
trap handleexitsignal EXIT


# PARSE COMMAND-LINE ARGUMENTS

argsURIs=()
argsOptions=()
while [[ "$#" -gt 0 ]] ; do
    case "$1" in
        --epichrome-debug)
            debug=1
            ;;

	--epichrome-preserve-logs)
	    logPreserve=1
	    ;;

	[hH][tT][tT][pP]'://'*|[hH][tT][tT][pP][sS]'://'*|[fF][tT][pP]'://'*|[fF][iI][lL][eE]'://'*)
	    # this should be sent to the open command
	    argsURIs+=( "$1" )
	    ;;

	*)
	    # pass any other options along to the engine
	    argsOptions+=( "$1" )
    esac

    # get next arg
    shift
done


# READ CURRENT APP SETTINGS

readconfig "$mySettingsFile"


# OBTAIN LOCK OR HAND OFF TO RUNNING ENGINE

if ! lockset ; then
    
    # lock already in use -- see if it's a live engine
    if kill -0 "$lockEnginePID" 2> /dev/null ; then
	
	# engine is already running, so just send any files or URLs to it &
	# don't run the usual command-line
	
	try /usr/bin/open -a "$myEnginePath/$SSBEngineAppName" "${argsURIs[@]}" \
	    'Unable to connect to running app engine.'
	
	# we're done, so exit
	[[ "$ok" ]] && exit 0
	exit 1
    else

	# locked but not with a running engine, so log error & quit
	abortsilent 'Unable to set lock.'
    fi
fi


# # get the ID of the engine app   $$$ NOT NEEDED IF REWRITE GETENGINEPID
# if [[ "$SSBEngineType" = "Google Chrome" ]] ; then
#     myEngineID="$googleChromeID"
# else
#     myEngineID="${appEngineIDBase}.${SSBIdentifier}"
# fi


# USEFUL PATHS

myContents="$myAppPath/Contents"


# UPDATE ENGINE APP NAME

# regex for pulling out current app name
appNameRe='/([^/]+)\.[aA][pP][pP]$'

# try to use current name of this Epichrome app as engine name
if [[ "$myAppPath" =~ $appNameRe ]] ; then
    SSBEngineAppName="${BASH_REMATCH[1]}.app"
else
    # if app name is unparsable, just use Info.plist display name
    SSBEngineAppName="${CFBundleDisplayName}.app"
fi

# rename engine app bundle
if [[ "$SSBEngineAppName" != "$configSSBEngineAppName" ]] ; then
    try mv "$myEnginePath/$configSSBEngineAppName" "$myEnginePath/$SSBEngineAppName" \
	'Unable to rename engine to match app name.'

    # an error here is non-fatal
    if [[ "$ok" ]] ; then
	errlog "$errmsg"
	ok=1 ; errmsg=

	# set engine app name back to original
	SSBEngineAppName="$configSSBEngineAppName"
    fi
fi

# get path to engine app bundle
myEngineAppPath="$myEnginePath/$SSBEngineAppName"
# myEngineAppContents="$myEngineAppPath/Contents"  $$$$ GET RID OF ALL REFERENCES


# ENGINE IS NOT RUNNING, SO GATHER MORE INFO

# CHECK FOR NEW VERSION OF EPICHROME AND UPDATE

safesource "${BASH_SOURCE[0]%/*}/Scripts/epichromeinfo.sh"
[[ "$ok" ]] || abort
   
# get info on latest Epichrome version
getepichromeinfo
[[ "$ok" ]] || abort "$errmsg"

epiLatestVersion="${epiLatest[$e_version]}"

if vcmp "$SSBUpdateVersion" '<' "$epiLatestVersion" ; then
    
    # authenticate  $$$ REMOVE THIS?
    # authenticate epichromeupdate "A new version of the Epichrome runtime was found ($epiLatestVersion)." \
    # 		 'update' nonfatal
    # if [[ "$?" = 0 ]] ; then

    # # Ask about updating (unless we asked with the authentication dialog)
    # if [[ "$isAdmin" != epichromeupdate ]] ; then

    updateMsg="A new version of Epichrome was found ($epiLatestVersion). Would you like to update this app?"
    updateBtnUpdate='Update'
    updateBtnLater='Later'
    
    if visbeta "$epiLatestVersion" ; then
	updateMsg="$updateMsg

IMPORTANT NOTE: This is a BETA release, and may be unstable. Updating cannot be undone! Please back up both this app and your data directory ($myDataPath) before updating."
	updateBtnUpdate="-$updateBtnUpdate"
	updateBtnLater="+$updateBtnLater"
    else
	updateBtnUpdate="+$updateBtnUpdate"
	updateBtnLater="-$updateBtnLater"
    fi
    
    dialog doUpdate \
	   "$updateMsg" \
	   "Update" \
	   "|caution" \
	   "$updateBtnUpdate" \
	   "$updateBtnLater" \
	   "Don't Ask Again For This Version"
    if [[ ! "$ok" ]] ; then
	alert "A new version of the Epichrome runtime was found ($epiLatestVersion) but the update dialog failed. Attempting to update now." 'Update' '|caution'
	doUpdate="Update"
	ok=1
	errmsg=
    fi
else
    doUpdate="Update"
fi

if [[ "$ok" ]] ; then

    # act based on dialog
    case "$doUpdate" in
	Update)

	    # read in the new runtime
	    safesource "${epiLatest[$e_contents]}/Resources/Scripts/update.sh" "update script $epiLatestVersion"
	    
	    # use new runtime to update the SSB (and relaunch)
	    updateapp "$myAppPath"
	    
	    # $$$$ MOVE THIS BACK INTO UPDATEAPP???
	    if [[ "$ok" ]] ; then
		
		# SUCCESS -- relaunch & exit
		relaunch "$myAppPath"
		exit 0  # not necessary, but for clarity
		
	    else
		
		# UPDATE FAILED -- reload my runtime
		
		# temporarily turn OK back on & reload old runtime
		oldErrmsg="$errmsg" ; errmsg=
		oldOK="$ok" ; ok=1
		safesource "$myContents/Resources/Scripts/core.sh" "core script $SSBVersion"
		[[ "$ok" ]] && ok="$oldOK"
		
		# update error message
		if [[ "$oldErrmsg" && "$errmsg" ]] ; then
		    errmsg="$oldErrmsg $errmsg"
		elif [[ "$oldErrmsg" ]] ; then
		    errmsg="$oldErrmsg"
		fi
	    fi
	    ;;

	Later)
	    # don't update
	    doUpdate=
	    ;;

	*)
	    # pretend we're already at the new version
	    SSBUpdateVersion="$epiLatestVersion"
	    ;;
    esac
fi
    
# alert the user to any error, but don't abort
if [[ ! "$ok" ]] ; then
    alert "$errmsg Please try update again later." 'Unable to Update' '|caution'
    ok=1
    errmsg=
fi


# CHECK FOR A NEW VERSION OF EPICHROME ON GITHUB

try 'curDate=' /bin/date '+%s' 'Unable to get date for Epichrome update check.'
if [[ "$ok" ]] ; then

    # check for updates if we've never run a check, or if the next check date is in the past
    if [[ ( ! "$SSBUpdateCheckDate" ) || ( "$SSBUpdateCheckDate" -lt "$curDate" ) ]] ; then

	# set next update for 7 days from now
	SSBUpdateCheckDate=$(($curDate + (7 * 24 * 60 * 60)))

	# if we haven't set a version to check against, use the latest version
	[[ "$SSBUpdateCheckVersion" ]] || SSBUpdateCheckVersion="$epiLatestVersion"

	# check if there's a new version on Github
	try 'updateResult=(n)' checkepichromeversion "$myContents" "$SSBUpdateCheckVersion" \
	    'Unable to check for a new version of Epichrome on Github.'
	if [[ "$ok" ]] ; then
	    
	    # if there's an update available, display a dialog
	    if [[ "${updateResult[*]}" ]] ; then
		
		# display dialog
		dialog doEpichromeUpdate \
		   "A new version of Epichrome (${updateResult[0]}) is available on GitHub." \
		   "Update Available" \
		   "|caution" \
		   "+Download" \
		   "-Later" \
		   "Ignore This Version"

		# act based on dialog
		if [[ "$ok" ]] ; then

		    case "$doEpichromeUpdate" in
			Download)
			    # open the update URL
			    try /usr/bin/open "${updateResult[1]}" 'Unable to open update URL.'
			    ;;
			
			Later)
			    # do nothing
			    doEpichromeUpdate=
			    ;;
			*)
			    # pretend we're already at the new version
			    SSBUpdateCheckVersion="${updateResult[0]}"
			    ;;
		    esac
		fi
	    fi
	fi
    fi
fi

# alert the user to any error, but don't abort
if [[ ! "$ok" ]] ; then
    alert "Warning: $errmsg" 'Checking For Update' '|caution'
    ok=1 ; errmsg=
fi


# POPULATE DATA DIRECTORY

# if this is our first run on a new version, force an update of the data dir
if [[ "$SSBFirstRunSinceVersion" ]] ; then
    forcePopulate=1
else
    forcePopulate=
fi

# if there's currently no profile directory, trigger first-run welcome message
if [[ ! -d "$myProfilePath" ]] ; then
    argsURIs=( "${argsURIs[@]}" "file://$myContents/Resources/FirstRun/welcome.html" )
fi

# populate the data directory
populatedatadir "$forcePopulate" ; populateResult="$?"
[[ "$ok" ]] || abort

# report and clear non-fatal error
if [[ "$populateResult" != 0 ]] ; then
    
    if [[ "$SSBExtensionInstallError" != "$errmsg" ]] ; then

	populateErrorMsg="Warning: Unable to install \"Epichrome Runtime\" extension. ($errmsg) Your app will still work, but"
	
	if [[ "$populateResult" = 2 ]] ; then
	    
	    # show warning alert for error auto-installing extension
	    alert "$populateErrorMsg if you want to use the extension, you'll have to install it manually." 'Extension Install Error' '|caution'
	else

	    # show warning alert for error installing native messaging host
	    alert "$populateErrorMsg the extension won't." 'Extension Install Error' '|caution'
	fi
	
	# set new error state
	SSBExtensionInstallError="$errmsg"
    fi
    
    # clear error state
    errmsg=
fi


# UPDATE LINKS TO CHROME NATIVE MESSAGING HOSTS

linktonmh

# report non-fatal error
if [[ ! "$ok" ]] ; then
    alert "Warning: $errmsg." 'Unable to Link to Native Messaging Hosts' '|caution'
    ok=1 ; errmsg=
fi

    
# CREATE OR UPDATE ENGINE IF NECESSARY

# flag whether we need to (re)create the engine
doCreateEngine=

if [[ "$SSBFirstRunSinceVersion" ]] ; then

    # this app was just updated or created, so we need a new engine
    doCreateEngine=1
    
    debuglog "Updating engine for new Epichrome version $SSBVersion."
    createEngineErrMsg="Unable to update engine for new Epichrome version $SSBVersion."
else
    
    # check the state of the engine
    if ! checkengine OFF ; then

	# get engine state
	local engineState="$?"

	# if engine is good but was left active, reset it
	if [[ "$engineState" = 2 ]] ; then
	    setenginestate OFF
	else
	    doCreateEngine=1
	    debuglog "Replacing corrupt engine."
	    createEngineErrMsg='Unable to replace corrupt engine.'
	fi
    fi
fi
[[ "$ok" ]] || abort

# create whatever needs creating
if [[ "$doCreateEngine" ]] ; then
    
    createengine
    [[ "$ok" ]] || abort "$createEngineErrMsg ($errmsg)"
    
elif [[ "$SSBEngineType" = "Google Chrome" ]] ; then
    
    # get info on the installed Google Chrome
    googlechromeinfo
    
    # new version of Google Chrome
    if [[ "$SSBEngineVersion" != "$configSSBEngineVersion" ]] ; then
	
	debuglog "Updating engine payload to Google Chrome version $SSBGoogleChromeVersion."
	createenginepayload

	[[ "$ok" ]] || abort "$Unable to update engine payload to Google Chrome version $SSBGoogleChromeVersion. ($errmsg)"
    fi
fi


# ACTIVATE ENGINE

setenginestate ON
[[ "$ok" ]] || abort


# UPDATE CONFIG FILE IF NECESSARY

# update config variables that may have changed
SSBFirstRunSinceVersion=
SSBAppPath="$myAppPath"

# write out config file if anything has changed
writeconfig "$myContents"

[[ "$ok" ]] || abort "$errmsg" 1


# LAUNCH APP ENGINE

# export Google API keys for Chromium engine
if [[ "$SSBEngineType" != "Google Chrome" ]] ; then
    export GOOGLE_API_KEY="AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k"
    export GOOGLE_DEFAULT_CLIENT_ID="811574891467.apps.googleusercontent.com"
    export GOOGLE_DEFAULT_CLIENT_SECRET="kdloedMFGdGla2P1zacGjAQh"
fi

# build command line
myArgs=( "${argsOptions[@]}" "${SSBCommandLine[@]}" )

# engine is not running, so launch as usual (still sending URIs to engine)

try /usr/bin/open -a "$myEngineAppPath" "${argsURIs[@]}" --args "--user-data-dir=$myProfilePath" "${myArgs[@]}" \
	'Unable to launch app.'
[[ "$ok" ]] || abort

# find PID & launch cleanup process

sleep 0.5
getenginepid "$myEngineID" "$myEngineAppPath"

if [[ "$enginePID" ]] ; then

    # $$$$ MAYBE MANUALLY EXPORT NEEDED LAUNCH.SH FUNCTIONS HERE

    # set state for helper
    epiHelperMode=LaunchCleanup ; export epiHelperMode
    epiHelperParentPID="$$" ; export epiHelperParentPID
    
    # PID found, so launch cleanup daemon
    try /usr/bin/open "$myContents/$appCleanupPath" \
	'Unable to launch cleanup helper. The app engine will not be properly cleaned up upon quitting.'
    [[ "$ok" ]] || alert "$errmsg" 'Warning' '|caution'

    # disown our lock
    lockOn=

else
    
    # PID not found, display error message and quit
    [[ "$errmsg" ]] && errmsg="$errmsg "
    alert "${errmsg}Your app may not have launched properly. If it did, the engine will not be properly cleaned up upon quitting." 'Warning' '|caution'
fi
