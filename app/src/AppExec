#!/bin/sh
#
#  AppExec: Run an Epichrome app
#
#  Copyright (C) 2020  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


# CORE APP INFO

# filled in by Makefile
SSBVersion='EPIVERSION'               
#readonly SSBVersion

# filled in by updateapp
SSBIdentifier=APPID
CFBundleDisplayName=APPDISPLAYNAME
CFBundleName=APPBUNDLENAME
SSBCustomIcon=APPCUSTOMICON
SSBCommandLine=APPCOMMANDLINE
SSBEngineType=APPENGINETYPE
APPENGINESOURCE
#readonly SSBIdentifier CFBundleDisplayName CFBundleName SSBCustomIcon SSBCommandLine SSBEngineType

export SSBIdentifier SSBVersion CFBundleDisplayName CFBundleName SSBCommandLine SSBEngineType SSBEngineSourceInfo


# CORE APP VARIABLES

myAppPath="${BASH_SOURCE[0]%/Contents/Resources/script}"


# LOAD CORE SCRIPT

myLogID=   # reset log ID
source "$myAppPath/Contents/Resources/Scripts/core.sh" PRESERVELOG || exit 1
[[ "$ok" ]] || abort

# ensure we have a data directory
[[ -d "$myDataPath" ]] || abort 'Unable to create data directory.'


# HANDLE KILL SIGNALS

function handleexitsignal {
    if [[ "$lockOn" ]] ; then
	errlog 'Terminated prematurely. Cleaning up.'
	lockrelease
    fi
}
trap '' INT
trap handleexitsignal EXIT


# FUNCTION DEFINITIONS


# CLEANUP -- release any lock we've set
function cleanup {
    [[ "$lockOn" ]] && lockrelease
}


# READCONFIG: read in config.sh file & save config versions to track changes
function readconfig { # ( myConfigFile )

    # only run if we're OK
    [[ "$ok" ]] || return 1

    # arguments
    local myConfigFile="$1" ; shift
    
    # read in config file
    safesource "$myConfigFile" 'configuration file'	
    [[ "$ok" ]] || return 1
    
    # save all relevant config variables prefixed with "config"
    for varname in "${appConfigVars[@]}" ; do
	
	if isarray "$varname" ; then

	    # array value
	    
	    eval "config$varname=(\"\${$varname[@]}\") ; export config$varname"
	    [[ "$debug" ]] && eval "errlog \"$varname=( \${config$varname[*]} )\""
	else
	    
	    # scalar value
	    
	    eval "config$varname=\"\${$varname}\" ; export config$varname"
	    [[ "$debug" ]] && eval "errlog \"$varname='\$config$varname'\""
	fi	    
    done
    
} ; export -f readconfig


# LOCK FUNCTIONS

# lock file
myLockFile="$myDataPath/lock" ; export myLockFile

# (do NOT export these -- they should not be inherited)
lockOn=
lockPID=
lockPath=
lockEnginePID=
lockEnginePath=

# LOCKSET -- set a lock file, or fail if it's already set
function lockset {

    # only run if we're OK
    [[ "$ok" ]] || return 1
    
    # error: lock variable is already set
    if [[ "$lockOn" ]] ; then
	errmsg='Lock variable is already set.'
	ok=
	return 1
    fi
    
    # check if there's already a lock file in place    
    if [[ -f "$myLockFile" ]] ; then
	
	# read the existing lock file
	safesource "$myLockFile" 'lock'
	[[ "$ok" ]] || return 1
	
	if [[ "$lockPID" = "$$" ]] ; then
	    
	    # error: this is already our lock
	    errmsg='Lock is already set.'
	    ok=
	    return 1
	    
	else

	    local curPID=
	    local curPath=
	    
	    # if lock's app (or helper) is still alive, we fail
	    if kill -0 "$lockPID" 2> /dev/null ; then

		# if this is the helper app, we need to use ps
		# since the helper executable is a script

		# see if this is the helper
		local epiHelperRe="${appHelperPath//\//\\/}"
		epiHelperRe="${epiHelperRe//./\\.}\$"
		if [[ "$lockPath" =~ $epiHelperRe ]] ; then

		    # get ps info for the lock PID
		    local epiHelperPS=
		    try 'epiHelperPS=' /bin/ps -o command -p "$lockPID" \
			"Unable to get process info for PID $lockPID"
		    if [[ "$ok" ]] ; then

			# check if the process is in fact the helper
			epiHelperRe="${lockPath//\//\\/}"
			epiHelperRe="${epiHelperRe//./\\.}"
			if [[ "$epiHelperPS" =~ $epiHelperRe ]] ; then
			    debuglog "Can't set lock: Another instance of this app's helper is alive at $lockPID."
			    return 1
			fi
		    else
			
			# error on ps, so just assume the process isn't alive
			ok=1 ; errmsg=
		    fi
		elif getrunningappinfo "$lockPath" curPID curPath && \
			[[ "$curPID" = "$lockPID" ]] ; then

		    # it's really this app that's already running
		    debuglog "Can't set lock: Another instance of this app is alive at $lockPID."
		    return 1
		fi
	    fi
	    
	    # if the lock's engine is still alive, we fail
	    if kill -0 "$lockEnginePID" 2> /dev/null ; then
		if getrunningappinfo "$lockEnginePath" curPID curPath && \
			[[ "$curPID" = "$lockEnginePID" ]] ; then
		    
		    debuglog "Can't set lock: This app's engine is alive at $lockEnginePID."
		    return 1
		fi
	    fi
	fi
    fi
    
    # if we got here, there's either no lock, or we can stomp on an old one
    lockPID="$$" ; lockPath="$myAppPath" ; lockEnginePID= ; lockEnginePath=
    writevars "$myLockFile" lockPID lockPath lockEnginePID lockEnginePath
    savelog
    [[ "$ok" ]] || return 1
    
    # return success
    debuglog "Lock set."
    lockOn=1
    return 0
}


# LOCKRELEASE -- release a lock file
function lockrelease {

    if [[ "$lockOn" ]] ; then
	
	# release lock variable
	lockOn=
	
	if [[ -f "$myLockFile" ]] ; then
	    
	    # command to delete lock file
	    local myCommand=( /bin/rm -f "$myLockFile" )

	    debuglog "Deleting lock."
	    
	    if [[ "$ok" ]] ; then
		
		try "${myCommand[@]}" 'Unable to delete old lock file.'
		
		# error is non-fatal: log error message, then clear error
		if [[ ! "$ok" ]] ; then
		    errlog "$errmsg"
		    ok=1 ; errmsg=
		fi
		
	    else
		tryonerr "${myCommand[@]}" 'Also unable to delete old lock file.'
	    fi
	    
	    return 0
	else
	    
	    # no lock file found
	    debuglog "Lock file not found."
	    return 1
	fi
	
    else
	
	# no lock set
	debuglog "No lock set."
	return 1
    fi
}

# export lock functions
export -f lockrelease


# MAIN BODY


# PARSE COMMAND-LINE ARGUMENTS

argsURIs=()
argsOptions=()
export argsURIs argsOptions
while [[ "$#" -gt 0 ]] ; do
    case "$1" in
        --epichrome-debug)
            debug=1
            ;;

	--epichrome-preserve-logs)
	    logPreserve=1
	    ;;

	[hH][tT][tT][pP]'://'*|[hH][tT][tT][pP][sS]'://'*|[fF][tT][pP]'://'*|[fF][iI][lL][eE]'://'*)
	    # this should be sent to the open command
	    argsURIs+=( "$1" )
	    ;;

	*)
	    # pass any other options along to the engine
	    argsOptions+=( "$1" )
    esac

    # get next arg
    shift
done


# OBTAIN LOCK OR HAND OFF TO RUNNING ENGINE

if ! lockset ; then
    
    # lock already in use -- see if it's a live engine
    if kill -0 "$lockEnginePID" 2> /dev/null ; then
	
	# engine is already running, so just send any files or URLs to it &
	# don't run the usual command-line
	debuglog "Activating already-running engine at '$lockEnginePath'"
	try /usr/bin/open -a "$lockEnginePath" "${argsURIs[@]}" \
	    'Unable to connect to running app engine.'
	
	# we're done, so exit one way or the other
	[[ "$ok" ]] && exit 0 || abort
    else
	
	# locked but not with a running engine, so log error & quit
	abortsilent 'Unable to set lock.'
    fi
fi


# ENGINE IS NOT RUNNING -- PREPARE TO LAUNCH ENGINE

# REINITIALIZE LOG

# if we're not keeping logs, clear it now
[[ "$logPreserve" ]] || initlog


# READ CURRENT APP SETTINGS

# add extra config vars for external engine
[[ "${SSBEngineType%%|*}" != internal ]] && appConfigVars+=( SSBEngineSourceInfo )

# read config file (if any)
if [[ -f "$myConfigFile" ]] ; then
    readconfig "$myConfigFile"
    [[ "$ok" ]] || abort
else
    debuglog "No configuration file found."
fi

# determine if this is our first run on a new version
isFirstRun=
isAppChanged=
showWelcomePage=
myWelcomeArgs=
if [[ "$SSBVersion" != "$SSBLastRunVersion" ]] ; then
    # mark as first run
    isFirstRun=1
    isAppChanged=1
    
    # show welcome page
    showWelcomePage=1
    [[ "$SSBLastRunVersion" ]] && myWelcomeArgs="u=$(encodeurl "$SSBLastRunVersion")"
    
    # update last run variables
    SSBLastRunVersion="$SSBVersion"
    SSBUpdateVersion="$SSBVersion"
    
    # clear extension install error state
    SSBNMHInstallError=
fi

# if nothing configured for last-run engine, set it to current engine
[[ "$SSBLastRunEngineType" ]] || SSBLastRunEngineType="$SSBEngineType"

# if there's no profile directory, trigger first-run welcome message
[[ -d "$myProfilePath" ]] || showWelcomePage=1


# UPDATE APP PATH
    
SSBAppPath="$myAppPath"


# LOAD LAUNCH FUNCTIONS

safesource "$myAppPath/Contents/Resources/Scripts/launch.sh"
[[ "$ok" ]] || abort


# GET EPICHROME INFO

getepichromeinfo


# UPDATE ENGINE PATH

if [[ ( -d "$SSBEnginePath" ) && \
	  ( "$epiCurrentPath" && \
		( "${SSBEnginePath%/$appEnginePathBase/*}" != "${epiCurrentPath%/*}" ) ) ||
	      ( ( ! "$epiCurrentPath" ) && "$epiLatestPath" && \
		    ( "${SSBEnginePath%/$appEnginePathBase/*}" != "${epiLatestPath%/*}" ) ) ]] ; then
    
    # engine path is not next to the current Epichrome (or latest one if no current), so we'll move it
    debuglog "Engine path '$SSBEnginePath' in outdated location."
    # $$$$ TEMP FOR KILLING THE UNKILLABLE BETA 6 ENGINE UGH
    try /bin/chmod -R u+w "$SSBEnginePath" 'Unable to fix permissions for old engine.'
    try /bin/rm -rf "$SSBEnginePath" 'Unable to remove old engine.'
    if [[ ! "$ok" ]] ; then
	errlog "Warning: $errmsg"
	ok=1 ; errmsg=
    fi

fi
if [[ ! -d "$SSBEnginePath" ]] ; then
    
    # start with Epichrome.app location
    if [[ -d "$epiCurrentPath" ]] ; then
	SSBEnginePath="$epiCurrentPath"
    elif [[ -d "$epiLatestPath" ]] ; then
	SSBEnginePath="$epiLatestPath"
    else
	# last ditch -- use default install location
	SSBEnginePath='/Applications/Epichrome/Epichrome.app'
    fi

    # get directory path
    SSBEnginePath="${SSBEnginePath%/*}/$appEnginePathBase"
    
    # determine if path is in our user path
    if [[ "${SSBEnginePath::${#HOME}}" = "$HOME" ]] ; then
	# path is user-level, so just add our app ID
	SSBEnginePath+="/$SSBIdentifier"
    else
	# path is root-level, so add our user ID & app ID  $$$ STICKY BIT SHOULD TAKE CARE OF THIS
	SSBEnginePath+="/$USER/$SSBIdentifier"
	# try /bin/mkdir -p "$SSBEnginePath" \
	#     "Unable to create user engine directory at '${SSBEnginePath%/$USER}'"
	# try /bin/chmod 700 "$SSBEnginePath" \
	#     "Unable to set permissions for user engine directory at '${SSBEnginePath%/$USER}'"
	# SSBEnginePath+="/$SSBIdentifier"
    fi

    debuglog "Setting engine path to '$SSBEnginePath'"
fi

# subsidiary paths
myEnginePayloadPath="$SSBEnginePath/Payload"
myEnginePlaceholderPath="$SSBEnginePath/Placeholder"
export myEnginePayloadPath myEnginePlaceholderPath


# UPDATE ENGINE APP NAME

# regex for pulling out current app name
appNameRe='/([^/]+)\.[aA][pP][pP]$'

# try to use current name of this Epichrome app as engine name
if [[ "$SSBAppPath" =~ $appNameRe ]] ; then
    SSBEngineAppName="${BASH_REMATCH[1]}.app"
else
    # if app name is unparsable, just use Info.plist display name
    SSBEngineAppName="${CFBundleDisplayName}.app"
fi

# rename engine app bundle
if [[ "$configSSBEngineAppName" && \
	  ( "$SSBEngineAppName" != "$configSSBEngineAppName" ) ]] ; then
    if [[ -d "$SSBEnginePath/$configSSBEngineAppName" ]] ; then
	try /bin/rm -rf "$SSBEnginePath/$SSBEngineAppName" \
	    'Unable to clear old engine app name.'
	try /bin/mv "$SSBEnginePath/$configSSBEngineAppName" "$SSBEnginePath/$SSBEngineAppName" \
	    'Unable to rename engine to match app name.'
	
	# an error here is non-fatal
	if [[ ! "$ok" ]] ; then
	    errlog "$errmsg"
	    ok=1 ; errmsg=
	    
	    # set engine app name back to original
	    SSBEngineAppName="$configSSBEngineAppName"
	fi
    fi
fi

# get path to engine app bundle
myEngineAppPath="$SSBEnginePath/$SSBEngineAppName"
export myEngineAppPath


# CHECK FOR NEW EPICHROME ON SYSTEM AND OFFER TO UPDATE

checkappupdate
if [[ "$?" != 0 ]] ; then

    # abort on fatal error
    [[ "$ok" ]] || abort

    # display warning on non-fatal error
    alert "$errmsg Please try update again later." 'Unable to Update' '|caution'
    ok=1
    errmsg=
fi

# CHECK FOR NEW EPICHROME ON GITHUB AND OFFER TO DOWNLOAD

checkgithubupdate

# alert the user to any error, but don't abort
if [[ ! "$ok" ]] ; then
    alert "Warning: Unable to check for new version of Epichrome on GitHub: $errmsg" 'Checking For Update' '|caution'
    ok=1 ; errmsg=
fi


# IF USING EXTERNAL ENGINE, GET INFO

if [[ "${SSBEngineType%%|*}" != internal ]] ; then
    
    # try the path we've been using first
    [[ "${SSBEngineSourceInfo[$iPath]}" ]] && getextenginesrcinfo "${SSBEngineSourceInfo[$iPath]}"
    
    # if that fails, search the system for external engine
    [[ "${SSBEngineSourceInfo[$iPath]}" ]] || getextenginesrcinfo
fi


# HANDLE ENGINE CHANGE

if [[ "${SSBEngineType#*|}" != "${SSBLastRunEngineType#*|}" ]] ; then
    
    # mark engine change
    isAppChanged=1
    
    # show welcome page
    showWelcomePage=1
    [[ "$myWelcomeArgs" ]] && myWelcomeArgs+='&'
    myWelcomeArgs+="oe=$(encodeurl "$SSBLastRunEngineInfo")&ne=$(encodeurl "${SSBEngineSourceInfo[$iName]}")"
        
    # clear extension install error state
    SSBNMHInstallError=
    
fi


# POPULATE DATA DIRECTORY

# update the data directory
if ! updatedatadir "$isAppChanged" ; then
    [[ "$ok" ]] && alert "$errmsg" 'Warning' '|caution'
fi
[[ "$ok" ]] || abort

# update the profile directory
if ! updateprofiledir "$isAppChanged" ; then
    [[ "$ok" ]] && alert "$errmsg" 'Warning' '|caution'
fi
[[ "$ok" ]] || abort

# install native messaging host, reporting non-fatal errors
installnmh "$isFirstRun"
if [[ ! "$ok" ]] ; then    
    if [[ "$SSBNMHInstallError" != "$errmsg" ]] ; then
	
	# show warning alert for error installing native messaging host
	alert "Unable to install \"Epichrome Runtime\" extension. ($errmsg) Your app will work, but the extension won't." 'Warning' '|caution'
	
	# set new error state
	SSBExtensionInstallError="$errmsg"
    fi
    
    # clear error state
    ok=1 ; errmsg=
fi

# update links to compatible native messaging hosts, reporting non-fatal errors
if ! linkexternalnmhs ; then
    alert "Unable to link to native messaging hosts. Extensions that use native messaging may not work. ($errmsg)" 'Warning' '|caution'
    errmsg=
fi


# UPDATE LAST-RUN ENGINE INFO

SSBLastRunEngineType="$SSBEngineType"
SSBLastRunEngineInfo="${SSBEngineSourceInfo[$iName]}"


# CREATE OR UPDATE ENGINE IF NECESSARY

# flag whether we need to (re)create the engine and/or activate it
doCreateEngine=
doNotActivateEngine=

if [[ "$isFirstRun" ]] ; then
    
    # this app was updated, so we need a new engine
    doCreateEngine=1
    debuglog "Updating engine for new Epichrome version $SSBVersion."
    createEngineErrMsg="Unable to update engine for new Epichrome version $SSBVersion"
elif [[ "$isAppChanged" ]] ; then

    # this app was changed, so we need a new engine
    doCreateEngine=1
    debuglog "App has changed. Updating engine."
    createEngineErrMsg="Unable to update engine for changed app"
    
else
    
    # check the state of the engine
    checkengine OFF ; engineState="$?"
    
    # flag if engine is good but was left active
    if [[ "$engineState" = 1 ]] ; then
	doNotActivateEngine=1
    elif [[ "$engineState" = 2 ]] ; then
	doCreateEngine=1
	debuglog "Replacing damaged engine."
	createEngineErrMsg='Unable to replace damaged engine'
    fi
    # else engine is in the expected off state
    
    if [[ ( ! "$doCreateEngine" ) && ( "${SSBEngineType%%|*}" != internal ) ]] ; then

	# new version of external engine app
	if [[ "${SSBEngineSourceInfo[$iVersion]}" && \
		  ( "${SSBEngineSourceInfo[$iVersion]}" != "${configSSBEngineSourceInfo[$iVersion]}" ) ]] ; then
	    
	    doCreateEngine=1
	    debuglog "Updating engine to ${SSBEngineSourceInfo[$iDisplayName]} version ${SSBEngineSourceInfo[$iVersion]}."
	    createEngineErrMsg="Unable to update engine to ${SSBEngineSourceInfo[$iDisplayName]} version ${SSBEngineSourceInfo[$iVersion]}."
	fi
    fi
fi
[[ "$ok" ]] || abort

# create engine if necessary
if [[ "$doCreateEngine" ]] ; then
    
    # if engine was left activated, deactivate it before re-creating
    if [[ "$doNotActivateEngine" ]] ; then
	setenginestate OFF
	doNotActivateEngine=
    fi

    # (re)create engine
    createengine
    [[ "$ok" ]] || abort "$createEngineErrMsg: $errmsg"    
fi


# ACTIVATE ENGINE (IF NECESSARY)

if [[ ! "$doNotActivateEngine" ]] ; then
    setenginestate ON
fi
[[ "$ok" ]] || abort


# UPDATE/CREATE ENGINE MANIFEST IF NECESSARY

updateenginemanifest

# report non-fatal error
if [[ ! "$ok" ]] ; then
    alert "Unable to create engine info manifest. ($errmsg) The Epichrome extension may not work." 'Warning' '|caution'
    ok=1 ; errmsg=
fi


# UPDATE/CREATE CENTRAL NATIVE MESSAGING HOST MANIFESTS

if [[ "${SSBEngineSourceInfo[$iName]}" = Brave ]] ; then
    
    updatecentralnmh
    
    if [[ ! "$ok" ]] ; then
	alert "Unable to install central native messaging host manifests. ($errmsg) The Epichrome extension may not work." \
	      'Warning' '|caution'
	ok=1 ; errmsg=
    fi
fi


# LAUNCH APP ENGINE

# export Google API keys for Chromium engine (found on https://github.com/ezeeyahoo/ChromiumSyncEnabler)
if [[ "$SSBEngineType" = 'internal|org.chromium.Chromium' ]] ; then
    export GOOGLE_API_KEY="AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k"
    export GOOGLE_DEFAULT_CLIENT_ID="811574891467.apps.googleusercontent.com"
    export GOOGLE_DEFAULT_CLIENT_SECRET="kdloedMFGdGla2P1zacGjAQh"
fi

# build command line  $$$ PASSWORD IMPORT TEMPORARILY ENABLED
myArgs=( "${argsOptions[@]}" '--enable-features=PasswordImport' "${SSBCommandLine[@]}" )

# engine is not running, so launch as usual (still sending URIs to engine)
try /usr/bin/open -a "$myEngineAppPath" "${argsURIs[@]}" --args "--user-data-dir=$myProfilePath" "${myArgs[@]}" \
    'Unable to launch app.'
[[ "$ok" ]] || abort

# show welcome page if needed
if [[ "$showWelcomePage" ]] ; then

    # set up arguments
    [[ "$myWelcomeArgs" ]] && myWelcomeArgs="?$myWelcomeArgs"

    debuglog "Showing welcome page with URL file://$(encodeurl "$myDataPath/Welcome/$appWelcomePage" '/')$myWelcomeArgs"
    
    # pause to allow the app to open
    sleep 1.5   #  $$$$$ FIX OR REMOVE

    # launch the welcome page
    try '-1' "$myEngineAppPath/Contents/MacOS/${SSBEngineSourceInfo[$iExecutable]}" \
	"--user-data-dir=$myProfilePath" "file://$(encodeurl "$myDataPath/Welcome/$appWelcomePage" '/')$myWelcomeArgs" \
	'Unable to open welcome page.'

    # handle error
    if [[ ! "$ok" ]] ; then
	alert "$errmsg You may need to install the Epichrome extension manually. If you've just updated the app or changed the engine, other settings may be lost." \
	      'Warning' '|caution'
	ok=1 ; errmsg=
    fi
fi


# UPDATE CONFIG FILE IF NECESSARY

writeconfig "$myConfigFile"
[[ "$ok" ]] || abort


# LAUNCH CLEANUP PROCESS

# get PID of running engine
attempt=
for attempt in 0 1 2 3 4 5 6 7 8 9 ; do
    # break on error or if we found a PID
    getengineinfo "$myEngineAppPath" || break
    [[ "$myEnginePID" ]] && break
    errlog "Waiting for app engine to launch..."
    sleep .5
done

if [[ "$myEnginePID" ]] ; then
    
    # engine PID found, so launch helper
    launchhelper Cleanup

    # report any error
    [[ "$ok" ]] || alert "$errmsg The app engine will not be deactivated upon quitting." \
			 'Warning' '|caution'
    
    # disown our lock
    debuglog 'Leaving lock in place for Epichrome Helper.'
    lockOn=
    
else
    
    # PID not found, display error message and quit
    [[ "$errmsg" ]] && errmsg="$errmsg "
    alert "${errmsg}Your app may not have launched properly. If it did, the engine will not be properly cleaned up upon quitting." 'Warning' '|caution'
fi

# exit cleanly
cleanexit
