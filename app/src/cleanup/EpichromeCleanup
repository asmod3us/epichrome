#!/bin/sh
#
#  EpichromeCleanup: Process that waits for an Epichrome app to quit, then
#                    cleans up the app engine
#
#  Copyright (C) 2019  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  Full license at: http://www.gnu.org/licenses/ (V3,6/29/2007)
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 


# FUNCTION DEFINITIONS

# ABORT -- display an error alert and abort
function abort { # [myErrMsg code]
    
    # arguments
    local myErrMsg="$1" ; shift ; [[ "$myErrMsg" ]] || myErrMsg="$errmsg"
    local myCode="$1"   ; shift ; [[ "$myCode"   ]] || myCode=1
    
    # log error message
    local myAbortLog="Aborting: $myErrMsg"
    if [[ "$( type -t errlog )" = function ]] ; then
	errlog "$myAbortLog"
    else
	echo "$myAbortLog" 1>&2
	[[ -w "$logPath" ]] && echo "$myAbortLog" >> "$logPath"
    fi
    
    exit "$myCode"
}


# IMMEDIATELY FORK SO THAT /usr/bin/open WILL RETURN


if [[ "$1" != daemon ]] ; then
    "$0" daemon "$@" &
    exit 0
else
    shift
fi


# MAIN BODY


# BOOTSTRAP RUNTIME SCRIPT

source "${0%/MacOS/*}/Resources/Scripts/runtime.sh"
[[ "$?" != 0 ]] && abort 'Unable to load runtime script.'
[[ "$ok" ]] || abort


# PARSE OPTIONS

mode="$1" ; shift
triggerPID="$1" ; shift
myAppPath="$1" ; shift
logPath="$1" ; shift
stderrTempFile="$1" ; shift

# set flag for relaunch mode
doRelaunch=
[[ "$mode" = RELAUNCH ]] && doRelaunch=1

# set log info
if [[ "$doRelaunch" ]] ; then
    logApp="Relaunch[$$/$triggerPID]"
else
    logApp="Cleanup[$$/$triggerPID]"
fi

# initialize log
logPreserve=1  # don't delete any log created by the parent app
initlog

# check common arguments
[[ "$triggerPID" =~ ^[0-9]+$ ]] || abort "Bad engine PID '$triggerPID'"
[[ -d "$myAppPath" ]] || abort "Bad app path '$myAppPath'"

# set & check clean-up mode options
if [[ ! "$doRelaunch" ]] ; then
    
    SSBEngineType="$mode"
    
    # quality-check arguments    
    [[ ( "$SSBEngineType" = 'Google Chrome' ) || ( "$SSBEngineType" = 'Chromium' ) ]] || \
	abort "Bad engine type '$SSBEngineType'"
    
    # set up payload path
    myPayloadPath="${myAppPath%/*}/Payload"
fi

debuglog "waiting for parent app to quit"


# WAIT FOR APP ENGINE TO DIE, THEN CONVERT ENGINE BACK TO PAYLOAD

# wait for app to exit
while /bin/kill -0 "$triggerPID" 2> /dev/null ; do
    sleep 1
done

# handle relaunch and quit
if [[ "$doRelaunch" ]] ; then
    debuglog "App has quit, relaunching"
    
    try /usr/bin/open "$myAppPath" \
	"Unable to relaunch '$myAppPath'"
    
    exit 0
fi

debuglog "Engine has quit, beginning cleanup"

# make sure we can still find engine
if [[ ! -d "$myAppPath/Contents" ]] ; then
    # abort -- something has gone wrong, maybe app was renamed or moved
    abort "Cleanup error -- Can't find app engine."
fi

# build list of runtime elements to delete

deletelist=()
curdir=
i=

# all items in engine root except Contents
dirlist "$myAppPath" curdir 'app engine' '^Contents$'
for i in "${curdir[@]}" ; do
    deletelist+=( "$myAppPath/$i" )
done

if [[ "$SSBEngineType" != 'Google Chrome' ]] ; then
    # all items in Contents except Info.plist, MacOS & Resources
    dirlist "$myAppPath/Contents" curdir \
	    'Epichrome app engine Contents' \
	    '^((Info.plist)|(MacOS)|(Resources))$'
else
    # all items in Contents except MacOS & Resources
    dirlist "$myAppPath/Contents" curdir \
	    'Google Chrome app engine Contents' \
	    '^((MacOS)|(Resources))$'
fi
for i in "${curdir[@]}" ; do
    deletelist+=( "$myAppPath/Contents/$i" )
done

# all items in Resources except .lproj & .icns
dirlist "$myAppPath/Contents/Resources" curdir \
	'app engine Resources' '\.((icns)|(lproj))$'
for i in "${curdir[@]}" ; do
    deletelist+=( "$myAppPath/Contents/Resources/$i" )
done

# delete items
if [[ "${deletelist[*]}" ]] ; then
    try /bin/rm -rf "${deletelist[@]}" \
	'Unable to clean up app engine.'
fi

# report any errors with the deletion process
if [[ ! "$ok" ]] ; then
    ok=1
    errlog "Cleanup error -- $errmsg"
fi

# Chromium engine: rename Info.plist Info.plist.off
if [[ "$SSBEngineType" != "Google Chrome" ]] ; then
    try /bin/mv -f "$myAppPath/Contents/Info.plist" \
	"$myAppPath/Contents/Info.plist.off" \
	'Unable to deactivate payload Info.plist.'
    if [[ ! "$ok" ]] ; then
	ok=1
	errlog "Cleanup error -- $errmsg"
    fi
fi

# rename engine back to Payload
try /bin/mv -f "$myAppPath" "$myPayloadPath" \
    'Unable to restore Payload directory.'

# report any final error
if [[ ! "$ok" ]] ; then
    abort "Cleanup error -- $errmsg"
fi

debuglog "Cleanup completed successfully"
