#!/bin/sh
#
#  TestLaunch
#
#  Copyright (C) 2019  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  Full license at: http://www.gnu.org/licenses/ (V3,6/29/2007)
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 


# FUNCTION DEFINITIONS

# ABORT -- log an error and abort
function abort { # [myErrMsg code]
    
    # arguments
    local myErrMsg="$1" ; shift ; [[ "$myErrMsg" ]] || myErrMsg="$errmsg"
    local myCode="$1"   ; shift ; [[ "$myCode"   ]] || myCode=1
    
    # log error message
    local myAbortLog="Aborting: $myErrMsg"
    if [[ "$( type -t errlog )" = function ]] ; then
	errlog "$myAbortLog"
    else
	echo "$myAbortLog" 1>&2
	[[ -w "$logPath" ]] && echo "$myAbortLog" >> "$logPath"
    fi
    
    cleanexit "$myCode"
}


function cleanexit {
    
    local myCode="$1" ; shift ; [[ "$myCode" ]] || myCode=0
    
    if [[ -d "$libPath/Engine/OFF" ]] ; then
	ok=1 ; errmsg=
	
	try /bin/mv "$huskPath/Contents" "$libPath/Engine/ON" 'Error moving out engine contents.'
	try /bin/mv "$libPath/Engine/OFF" "$huskPath/Contents" 'Error moving in husk contents.'
	
	if [[ "$ok" ]] ; then
	    debuglog "cleanup complete"
	else
	    errlog "$errmsg"
	    [[ "$myCode" = 0 ]] && myCode=1
	fi	
    fi
    
    exit "$myCode"
}
    

# GETENGINEPID: get the PID of the running engine
enginePID=
function getenginepid { # ENGINE-BUNDLE-ID ENGINE-BUNDLE-PATH

    # assume no PID
    enginePID=

    # args
    local id="$1"
    local path="$2"

    # get all ASNs associated with the engine's bundle ID
    local asns=
    try 'asns=()' /usr/bin/lsappinfo find "bundleid=$id" \
	'Error while attempting to find running engine.'
    
    # no engine found, just don't return a PID
    if [[ "$ok" && ( "${#asns[@]}" = 0 ) ]] ; then
	debuglog "NO ASNS RETURNED"
	return 0
    fi

    # search for PID
    if [[ "$ok" ]] ; then

	local info=
	
	local a=
	for a in "${asns[@]}" ; do

	    # get info on an ASN (we use try for the debugging output)
	    try 'info=' /usr/bin/lsappinfo info "$a" ''
	    ok=1 ; errmsg=
	    
	    # if this ASN matches our bundle, grab the PID
	    re='bundle path *= *"([^'$'\n'']+)".*pid *= *([0-9]+)'

	    # if [[ "$info" =~ $re ]] ; then
	    # 	debuglog "checking ASN: '${BASH_REMATCH[1]}' pid ${BASH_REMATCH[2]}"
	    # 	debuglog "against path: '$path'"
	    # fi
	    
	    if [[ ( "$info" =~ $re ) && ( "${BASH_REMATCH[1]}" = "$path" ) ]] ; then
		enginePID="${BASH_REMATCH[2]}"
		break
	    fi

	    # not found, so reset info
	    info=
	done
    fi

    # return result
    if [[ "$enginePID" ]] ; then
	ok=1 ; errmsg=
	return 0
    elif [[ "$ok" ]] ; then
	return 0
    else
	# errors in this function are nonfatal; just return the error message
	ok=1
	return 1
    fi
}


# IMMEDIATELY FORK SO THAT /usr/bin/open WILL RETURN


if [[ "$1" != daemon ]] ; then
    "$0" daemon "$@" &
    exit 0
else
    shift
fi


# MAIN BODY


# BOOTSTRAP RUNTIME SCRIPT

source "${0%/MacOS/*}/Resources/Scripts/runtime.sh"
[[ "$?" != 0 ]] && abort 'Unable to load runtime script.'
[[ "$ok" ]] || abort

# PARSE OPTIONS

huskPID="$1"  ; shift
appName="$1"  ; shift
huskPath="$1" ; shift
appID="$1"    ; shift

libPath="$HOME/Library/Application Support/Epichrome/Apps/$appName"

# initialize log
logPath="$libPath/epichrome_app_log.txt"
stderrTempFile="$libPath/stderr.txt"
logApp="TestLaunch[$$/$huskPID]"
logPreserve=1  # don't delete any log created by the parent app
initlog

# $$$ HACK TO HANDLE BROWSER FAIRY DOUBLE-LAUNCH
try /bin/mv "$huskPath/Contents" "$libPath/Engine/OFF" 'Error moving out husk contents.'


# debuglog "huskPID = $huskPID"
# debuglog "appName = $appName"
# debuglog "huskPath = $huskPath"
# debuglog "appID = $appID"

# WAIT FOR HUSK APP TO DIE, THEN CONVERT TO ENGINE

debuglog "waiting for husk app to quit"

# wait for app to exit
while /bin/kill -0 "$huskPID" 2> /dev/null ; do
    sleep .5
done

logApp="TestLaunch[$$]"

# $$$ HACK TO HANDLE BROWSER FAIRY DOUBLE-LAUNCH
if [[ "$*" ]] ; then
    debuglog "opening files, so pausing before convert"
    sleep .5
fi

# handle engine launch
debuglog "husk app has quit, converting to engine"

try /bin/mv "$libPath/Engine/ON" "$huskPath/Contents" 'Error moving in engine contents.'
[[ "$ok" ]] || abort

debuglog "launching engine with args: $*"

# $$$$ if this fails with no executable, try again
# The application /Users/davidmarmor/Scratch/TestOneAppG.app cannot be opened because its executable is missing.
for attempt in 1 2 3 4 5 6 7 8 9 10 ; do
    if [[ "$attempt" != 1 ]] ; then
	debuglog "Trying open again..."
	ok=1 ; errmsg=
    fi
    
    try 'openerr&=' /usr/bin/open -a "$huskPath" "$@" --args "--user-data-dir=$libPath/UserData" '--app=https://www.imdb.com/' \
	"Unable to launch '$huskPath'"
    
    if [[ "$ok" ]] ; then
	debuglog "Open succeeded on attempt $attempt"
	break
    else
	debuglog "Open attempt $attempt failed: $openerr"
	sleep .5
    fi
done

[[ "$ok" ]] || abort

sleep 1

getenginepid "$appID" "$huskPath"

if [[ ! "$enginePID" ]] ; then
    abort "No engine PID"
fi

logApp="TestLaunch[$$/$enginePID]"

debuglog "waiting for engine to quit"

# wait for app to exit
while /bin/kill -0 "$enginePID" 2> /dev/null ; do
    sleep .66
done

debuglog "engine has quit, cleaning up"

cleanexit

#debuglog "Engine has quit, beginning cleanup"


#debuglog "Cleanup completed successfully"
