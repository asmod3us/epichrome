#!/bin/sh
#
#  EpichromeHelper: Helper app to clean up engines & handle app updates
#
#  Copyright (C) 2020  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  Full license at: http://www.gnu.org/licenses/ (V3,6/29/2007)
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 


# IMMEDIATELY FORK SO THAT /usr/bin/open WILL RETURN

if [[ "${epiHelperMode::6}" =~ ^Launch(.+)$ ]] ; then
    epiHelperMode="${BASH_REMATCH[1]}"
    "$0" "$@" &
    exit 0
else
    shift
fi


# FUNCTION DEFINITIONS


# CLEANUP -- restore launcher  $$$$ REWRITE THIS
function cleanup { # [code]
    
    local myCode="$1" ; shift ; [[ "$myCode" ]] || myCode=0
    
    # deactivate engine
    setenginestate OFF
    if [[ "$ok" ]] ; then
	debuglog "Cleanup complete."
    else
	errlog "$errmsg"
	[[ "$myCode" = 0 ]] && myCode=1
    fi
    
    # exit
    exit "$myCode"
}


# HANDLE KILL SIGNALS

function handleexitsignal {

    if kill -0 "$myEnginePID" 2> /dev/null ; then

	# engine is still running, so try to kill it gently
	errlog 'Terminated prematurely. Quitting engine.'
	try kill -HUP "$myEnginePID" 'Error sending HUP to engine.'
	if [[ ! "$ok" ]] ; then
	    errlog "$errmsg"
	    ok=1 ; errmsg
	fi

	# wait a few seconds
	sleep 5

	# if engine has now quit, clean up
	if ! kill -0 "$myEnginePID" 2> /dev/null ; then
	    debuglog 'Engine has quit. Cleaning up...'
	    cleanup
	else
	    debuglog 'Engine still running. Giving up and leaving engine active.'
	fi
    fi
    
    # if engine is already dead, assume we've already cleaned up
    
    # release lock
    lockrelease
    
}
trap '' INT
trap handleexitsignal EXIT


# LOCKREPLACE -- replace a lock set by the parent app
function lockreplace { # ( replacePID )

    if [[ "$ok" ]] ; then
	
	# PID of lock we want to replace
	local replacePID="$1" ; shift
	#local myLockEnginePID="$1" ; shift
	
	# assume lock is not already on
	lockOn=
	
	# check if there's already a lock file in place    
	if [[ -f "$myLockFile" ]] ; then
	    
	    # read the existing lock file
	    safesource "$myLockFile" 'lock'
	    [[ "$ok" ]] || return 1	    
	    
	    # if this is the right lock, replace it
	    if [[ "$replacePID" = "$lockPID" ]] ; then
		lockPID="$$"
		writevars "$myLockFile" lockPID lockEnginePID
		[[ "$ok" ]] || return 1
		lockOn=1
		return 0
	    else

		# replacement PID doesn't match lock PID
		ok= ; errmsg="Incorrect lock info."
		return 1
	    fi
	    
	else
	    
	    # we're supposed to be replacing a lock, but none in place
	    ok= ; errmsg="No lock found."
	    return 1
	fi
    fi

    return 1
}


# MAIN BODY

# update log name
myLogApp="TestLaunch[$$/$myEnginePID]"  # $$$$ FIX THIS


# REPLACE PARENT APP'S LOCK

lockEnginePID="$myEnginePID"

lockreplace "$epiHelperParentPID" || abort "Unable to acquire lock. ($errmsg) The app engine will not be deactivated upon quitting."


# WAIT FOR APP TO EXIT

debuglog "Waiting for engine to quit."
while kill -0 "$myEnginePID" 2> /dev/null ; do
    sleep .66
done


# DEACTIVATE ENGINE AND QUIT

debuglog 'Engine has quit. Cleaning up...'
cleanexit
